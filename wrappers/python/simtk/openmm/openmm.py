# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

"""
PyOpenMM is a Python application programming interface (API) to be
used for performing molecular dynamics (MD) simulations on various
computer architectures (including GPUs).  It is implemented in Python
and C/C++, and provides a Python interface to the OpenMM libraries
(see https://simtk.org/home/openmm for OpenMM details).  The primary
motivation for creating PyOpenMM is to make it possible to write
GPU-accelerated MD code in pure Python.

See https://simtk.org/home/pyopenmm for details
"""

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openmm', [dirname(__file__)])
        except ImportError:
            import _openmm
            return _openmm
        if fp is not None:
            try:
                _mod = imp.load_module('_openmm', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openmm = swig_import_helper()
    del swig_import_helper
else:
    import _openmm
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class ios_base(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ios_base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ios_base, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _openmm.ios_base_erase_event
    imbue_event = _openmm.ios_base_imbue_event
    copyfmt_event = _openmm.ios_base_copyfmt_event
    def register_callback(self, *args): return _openmm.ios_base_register_callback(self, *args)
    def flags(self, *args): return _openmm.ios_base_flags(self, *args)
    def setf(self, *args): return _openmm.ios_base_setf(self, *args)
    def unsetf(self, *args): return _openmm.ios_base_unsetf(self, *args)
    def precision(self, *args): return _openmm.ios_base_precision(self, *args)
    def width(self, *args): return _openmm.ios_base_width(self, *args)
    __swig_getmethods__["sync_with_stdio"] = lambda x: _openmm.ios_base_sync_with_stdio
    if _newclass:sync_with_stdio = staticmethod(_openmm.ios_base_sync_with_stdio)
    def imbue(self, *args): return _openmm.ios_base_imbue(self, *args)
    def getloc(self): return _openmm.ios_base_getloc(self)
    __swig_getmethods__["xalloc"] = lambda x: _openmm.ios_base_xalloc
    if _newclass:xalloc = staticmethod(_openmm.ios_base_xalloc)
    def iword(self, *args): return _openmm.ios_base_iword(self, *args)
    def pword(self, *args): return _openmm.ios_base_pword(self, *args)
    __swig_destroy__ = _openmm.delete_ios_base
    __del__ = lambda self : None;
ios_base_swigregister = _openmm.ios_base_swigregister
ios_base_swigregister(ios_base)
cvar = _openmm.cvar
ios_base.boolalpha = _openmm.cvar.ios_base_boolalpha
ios_base.dec = _openmm.cvar.ios_base_dec
ios_base.fixed = _openmm.cvar.ios_base_fixed
ios_base.hex = _openmm.cvar.ios_base_hex
ios_base.internal = _openmm.cvar.ios_base_internal
ios_base.left = _openmm.cvar.ios_base_left
ios_base.oct = _openmm.cvar.ios_base_oct
ios_base.right = _openmm.cvar.ios_base_right
ios_base.scientific = _openmm.cvar.ios_base_scientific
ios_base.showbase = _openmm.cvar.ios_base_showbase
ios_base.showpoint = _openmm.cvar.ios_base_showpoint
ios_base.showpos = _openmm.cvar.ios_base_showpos
ios_base.skipws = _openmm.cvar.ios_base_skipws
ios_base.unitbuf = _openmm.cvar.ios_base_unitbuf
ios_base.uppercase = _openmm.cvar.ios_base_uppercase
ios_base.adjustfield = _openmm.cvar.ios_base_adjustfield
ios_base.basefield = _openmm.cvar.ios_base_basefield
ios_base.floatfield = _openmm.cvar.ios_base_floatfield
ios_base.badbit = _openmm.cvar.ios_base_badbit
ios_base.eofbit = _openmm.cvar.ios_base_eofbit
ios_base.failbit = _openmm.cvar.ios_base_failbit
ios_base.goodbit = _openmm.cvar.ios_base_goodbit
ios_base.app = _openmm.cvar.ios_base_app
ios_base.ate = _openmm.cvar.ios_base_ate
ios_base.binary = _openmm.cvar.ios_base_binary
ios_base.ios_base_in = _openmm.cvar.ios_base_ios_base_in
ios_base.out = _openmm.cvar.ios_base_out
ios_base.trunc = _openmm.cvar.ios_base_trunc
ios_base.beg = _openmm.cvar.ios_base_beg
ios_base.cur = _openmm.cvar.ios_base_cur
ios_base.end = _openmm.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync = True):
  return _openmm.ios_base_sync_with_stdio(__sync)
ios_base_sync_with_stdio = _openmm.ios_base_sync_with_stdio

def ios_base_xalloc():
  return _openmm.ios_base_xalloc()
ios_base_xalloc = _openmm.ios_base_xalloc

class ios(ios_base):
    __swig_setmethods__ = {}
    for _s in [ios_base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ios, name, value)
    __swig_getmethods__ = {}
    for _s in [ios_base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ios, name)
    __repr__ = _swig_repr
    def rdstate(self): return _openmm.ios_rdstate(self)
    def clear(self, *args): return _openmm.ios_clear(self, *args)
    def setstate(self, *args): return _openmm.ios_setstate(self, *args)
    def good(self): return _openmm.ios_good(self)
    def eof(self): return _openmm.ios_eof(self)
    def fail(self): return _openmm.ios_fail(self)
    def bad(self): return _openmm.ios_bad(self)
    def exceptions(self, *args): return _openmm.ios_exceptions(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_ios(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_ios
    __del__ = lambda self : None;
    def tie(self, *args): return _openmm.ios_tie(self, *args)
    def rdbuf(self, *args): return _openmm.ios_rdbuf(self, *args)
    def copyfmt(self, *args): return _openmm.ios_copyfmt(self, *args)
    def fill(self, *args): return _openmm.ios_fill(self, *args)
    def imbue(self, *args): return _openmm.ios_imbue(self, *args)
    def narrow(self, *args): return _openmm.ios_narrow(self, *args)
    def widen(self, *args): return _openmm.ios_widen(self, *args)
ios_swigregister = _openmm.ios_swigregister
ios_swigregister(ios)

class ostream(ios):
    __swig_setmethods__ = {}
    for _s in [ios]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ostream, name, value)
    __swig_getmethods__ = {}
    for _s in [ios]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ostream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _openmm.new_ostream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_ostream
    __del__ = lambda self : None;
    def __lshift__(self, *args): return _openmm.ostream___lshift__(self, *args)
    def put(self, *args): return _openmm.ostream_put(self, *args)
    def write(self, *args): return _openmm.ostream_write(self, *args)
    def flush(self): return _openmm.ostream_flush(self)
    def tellp(self): return _openmm.ostream_tellp(self)
    def seekp(self, *args): return _openmm.ostream_seekp(self, *args)
ostream_swigregister = _openmm.ostream_swigregister
ostream_swigregister(ostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

class istream(ios):
    __swig_setmethods__ = {}
    for _s in [ios]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, istream, name, value)
    __swig_getmethods__ = {}
    for _s in [ios]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, istream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _openmm.new_istream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_istream
    __del__ = lambda self : None;
    def __rshift__(self, *args): return _openmm.istream___rshift__(self, *args)
    def gcount(self): return _openmm.istream_gcount(self)
    def get(self, *args): return _openmm.istream_get(self, *args)
    def getline(self, *args): return _openmm.istream_getline(self, *args)
    def ignore(self, *args): return _openmm.istream_ignore(self, *args)
    def peek(self): return _openmm.istream_peek(self)
    def read(self, *args): return _openmm.istream_read(self, *args)
    def readsome(self, *args): return _openmm.istream_readsome(self, *args)
    def putback(self, *args): return _openmm.istream_putback(self, *args)
    def unget(self): return _openmm.istream_unget(self)
    def sync(self): return _openmm.istream_sync(self)
    def tellg(self): return _openmm.istream_tellg(self)
    def seekg(self, *args): return _openmm.istream_seekg(self, *args)
istream_swigregister = _openmm.istream_swigregister
istream_swigregister(istream)

class iostream(istream,ostream):
    __swig_setmethods__ = {}
    for _s in [istream,ostream]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, iostream, name, value)
    __swig_getmethods__ = {}
    for _s in [istream,ostream]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, iostream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _openmm.new_iostream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_iostream
    __del__ = lambda self : None;
iostream_swigregister = _openmm.iostream_swigregister
iostream_swigregister(iostream)

endl_cb_ptr = _openmm.endl_cb_ptr

def endl(*args):
  return _openmm.endl(*args)
endl = _openmm.endl
ends_cb_ptr = _openmm.ends_cb_ptr

def ends(*args):
  return _openmm.ends(*args)
ends = _openmm.ends
flush_cb_ptr = _openmm.flush_cb_ptr

def flush(*args):
  return _openmm.flush(*args)
flush = _openmm.flush
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _openmm.SwigPyIterator_value(self)
    def incr(self, n = 1): return _openmm.SwigPyIterator_incr(self, n)
    def decr(self, n = 1): return _openmm.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _openmm.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _openmm.SwigPyIterator_equal(self, *args)
    def copy(self): return _openmm.SwigPyIterator_copy(self)
    def next(self): return _openmm.SwigPyIterator_next(self)
    def __next__(self): return _openmm.SwigPyIterator___next__(self)
    def previous(self): return _openmm.SwigPyIterator_previous(self)
    def advance(self, *args): return _openmm.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _openmm.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _openmm.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _openmm.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _openmm.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _openmm.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _openmm.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _openmm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class pairii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pairii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pairii, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _openmm.new_pairii(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _openmm.pairii_first_set
    __swig_getmethods__["first"] = _openmm.pairii_first_get
    if _newclass:first = _swig_property(_openmm.pairii_first_get, _openmm.pairii_first_set)
    __swig_setmethods__["second"] = _openmm.pairii_second_set
    __swig_getmethods__["second"] = _openmm.pairii_second_get
    if _newclass:second = _swig_property(_openmm.pairii_second_get, _openmm.pairii_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _openmm.delete_pairii
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

pairii_swigregister = _openmm.pairii_swigregister
pairii_swigregister(pairii)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr
    def iterator(self): return _openmm.vectord_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _openmm.vectord___nonzero__(self)
    def __bool__(self): return _openmm.vectord___bool__(self)
    def __len__(self): return _openmm.vectord___len__(self)
    def pop(self): return _openmm.vectord_pop(self)
    def __getslice__(self, *args): return _openmm.vectord___getslice__(self, *args)
    def __setslice__(self, *args): return _openmm.vectord___setslice__(self, *args)
    def __delslice__(self, *args): return _openmm.vectord___delslice__(self, *args)
    def __delitem__(self, *args): return _openmm.vectord___delitem__(self, *args)
    def __getitem__(self, *args): return _openmm.vectord___getitem__(self, *args)
    def __setitem__(self, *args): return _openmm.vectord___setitem__(self, *args)
    def append(self, *args): return _openmm.vectord_append(self, *args)
    def empty(self): return _openmm.vectord_empty(self)
    def size(self): return _openmm.vectord_size(self)
    def clear(self): return _openmm.vectord_clear(self)
    def swap(self, *args): return _openmm.vectord_swap(self, *args)
    def get_allocator(self): return _openmm.vectord_get_allocator(self)
    def begin(self): return _openmm.vectord_begin(self)
    def end(self): return _openmm.vectord_end(self)
    def rbegin(self): return _openmm.vectord_rbegin(self)
    def rend(self): return _openmm.vectord_rend(self)
    def pop_back(self): return _openmm.vectord_pop_back(self)
    def erase(self, *args): return _openmm.vectord_erase(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_vectord(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _openmm.vectord_push_back(self, *args)
    def front(self): return _openmm.vectord_front(self)
    def back(self): return _openmm.vectord_back(self)
    def assign(self, *args): return _openmm.vectord_assign(self, *args)
    def resize(self, *args): return _openmm.vectord_resize(self, *args)
    def insert(self, *args): return _openmm.vectord_insert(self, *args)
    def reserve(self, *args): return _openmm.vectord_reserve(self, *args)
    def capacity(self): return _openmm.vectord_capacity(self)
    __swig_destroy__ = _openmm.delete_vectord
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectord_swigregister = _openmm.vectord_swigregister
vectord_swigregister(vectord)

class vectorddd(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorddd, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorddd, name)
    __repr__ = _swig_repr
    def iterator(self): return _openmm.vectorddd_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _openmm.vectorddd___nonzero__(self)
    def __bool__(self): return _openmm.vectorddd___bool__(self)
    def __len__(self): return _openmm.vectorddd___len__(self)
    def pop(self): return _openmm.vectorddd_pop(self)
    def __getslice__(self, *args): return _openmm.vectorddd___getslice__(self, *args)
    def __setslice__(self, *args): return _openmm.vectorddd___setslice__(self, *args)
    def __delslice__(self, *args): return _openmm.vectorddd___delslice__(self, *args)
    def __delitem__(self, *args): return _openmm.vectorddd___delitem__(self, *args)
    def __getitem__(self, *args): return _openmm.vectorddd___getitem__(self, *args)
    def __setitem__(self, *args): return _openmm.vectorddd___setitem__(self, *args)
    def append(self, *args): return _openmm.vectorddd_append(self, *args)
    def empty(self): return _openmm.vectorddd_empty(self)
    def size(self): return _openmm.vectorddd_size(self)
    def clear(self): return _openmm.vectorddd_clear(self)
    def swap(self, *args): return _openmm.vectorddd_swap(self, *args)
    def get_allocator(self): return _openmm.vectorddd_get_allocator(self)
    def begin(self): return _openmm.vectorddd_begin(self)
    def end(self): return _openmm.vectorddd_end(self)
    def rbegin(self): return _openmm.vectorddd_rbegin(self)
    def rend(self): return _openmm.vectorddd_rend(self)
    def pop_back(self): return _openmm.vectorddd_pop_back(self)
    def erase(self, *args): return _openmm.vectorddd_erase(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_vectorddd(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _openmm.vectorddd_push_back(self, *args)
    def front(self): return _openmm.vectorddd_front(self)
    def back(self): return _openmm.vectorddd_back(self)
    def assign(self, *args): return _openmm.vectorddd_assign(self, *args)
    def resize(self, *args): return _openmm.vectorddd_resize(self, *args)
    def insert(self, *args): return _openmm.vectorddd_insert(self, *args)
    def reserve(self, *args): return _openmm.vectorddd_reserve(self, *args)
    def capacity(self): return _openmm.vectorddd_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorddd
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorddd_swigregister = _openmm.vectorddd_swigregister
vectorddd_swigregister(vectorddd)

class vectori(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectori, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectori, name)
    __repr__ = _swig_repr
    def iterator(self): return _openmm.vectori_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _openmm.vectori___nonzero__(self)
    def __bool__(self): return _openmm.vectori___bool__(self)
    def __len__(self): return _openmm.vectori___len__(self)
    def pop(self): return _openmm.vectori_pop(self)
    def __getslice__(self, *args): return _openmm.vectori___getslice__(self, *args)
    def __setslice__(self, *args): return _openmm.vectori___setslice__(self, *args)
    def __delslice__(self, *args): return _openmm.vectori___delslice__(self, *args)
    def __delitem__(self, *args): return _openmm.vectori___delitem__(self, *args)
    def __getitem__(self, *args): return _openmm.vectori___getitem__(self, *args)
    def __setitem__(self, *args): return _openmm.vectori___setitem__(self, *args)
    def append(self, *args): return _openmm.vectori_append(self, *args)
    def empty(self): return _openmm.vectori_empty(self)
    def size(self): return _openmm.vectori_size(self)
    def clear(self): return _openmm.vectori_clear(self)
    def swap(self, *args): return _openmm.vectori_swap(self, *args)
    def get_allocator(self): return _openmm.vectori_get_allocator(self)
    def begin(self): return _openmm.vectori_begin(self)
    def end(self): return _openmm.vectori_end(self)
    def rbegin(self): return _openmm.vectori_rbegin(self)
    def rend(self): return _openmm.vectori_rend(self)
    def pop_back(self): return _openmm.vectori_pop_back(self)
    def erase(self, *args): return _openmm.vectori_erase(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_vectori(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _openmm.vectori_push_back(self, *args)
    def front(self): return _openmm.vectori_front(self)
    def back(self): return _openmm.vectori_back(self)
    def assign(self, *args): return _openmm.vectori_assign(self, *args)
    def resize(self, *args): return _openmm.vectori_resize(self, *args)
    def insert(self, *args): return _openmm.vectori_insert(self, *args)
    def reserve(self, *args): return _openmm.vectori_reserve(self, *args)
    def capacity(self): return _openmm.vectori_capacity(self)
    __swig_destroy__ = _openmm.delete_vectori
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectori_swigregister = _openmm.vectori_swigregister
vectori_swigregister(vectori)

class vectorii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorii, name)
    __repr__ = _swig_repr
    def iterator(self): return _openmm.vectorii_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _openmm.vectorii___nonzero__(self)
    def __bool__(self): return _openmm.vectorii___bool__(self)
    def __len__(self): return _openmm.vectorii___len__(self)
    def pop(self): return _openmm.vectorii_pop(self)
    def __getslice__(self, *args): return _openmm.vectorii___getslice__(self, *args)
    def __setslice__(self, *args): return _openmm.vectorii___setslice__(self, *args)
    def __delslice__(self, *args): return _openmm.vectorii___delslice__(self, *args)
    def __delitem__(self, *args): return _openmm.vectorii___delitem__(self, *args)
    def __getitem__(self, *args): return _openmm.vectorii___getitem__(self, *args)
    def __setitem__(self, *args): return _openmm.vectorii___setitem__(self, *args)
    def append(self, *args): return _openmm.vectorii_append(self, *args)
    def empty(self): return _openmm.vectorii_empty(self)
    def size(self): return _openmm.vectorii_size(self)
    def clear(self): return _openmm.vectorii_clear(self)
    def swap(self, *args): return _openmm.vectorii_swap(self, *args)
    def get_allocator(self): return _openmm.vectorii_get_allocator(self)
    def begin(self): return _openmm.vectorii_begin(self)
    def end(self): return _openmm.vectorii_end(self)
    def rbegin(self): return _openmm.vectorii_rbegin(self)
    def rend(self): return _openmm.vectorii_rend(self)
    def pop_back(self): return _openmm.vectorii_pop_back(self)
    def erase(self, *args): return _openmm.vectorii_erase(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_vectorii(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _openmm.vectorii_push_back(self, *args)
    def front(self): return _openmm.vectorii_front(self)
    def back(self): return _openmm.vectorii_back(self)
    def assign(self, *args): return _openmm.vectorii_assign(self, *args)
    def resize(self, *args): return _openmm.vectorii_resize(self, *args)
    def insert(self, *args): return _openmm.vectorii_insert(self, *args)
    def reserve(self, *args): return _openmm.vectorii_reserve(self, *args)
    def capacity(self): return _openmm.vectorii_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorii
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorii_swigregister = _openmm.vectorii_swigregister
vectorii_swigregister(vectorii)

class vectorpairii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorpairii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorpairii, name)
    __repr__ = _swig_repr
    def iterator(self): return _openmm.vectorpairii_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _openmm.vectorpairii___nonzero__(self)
    def __bool__(self): return _openmm.vectorpairii___bool__(self)
    def __len__(self): return _openmm.vectorpairii___len__(self)
    def pop(self): return _openmm.vectorpairii_pop(self)
    def __getslice__(self, *args): return _openmm.vectorpairii___getslice__(self, *args)
    def __setslice__(self, *args): return _openmm.vectorpairii___setslice__(self, *args)
    def __delslice__(self, *args): return _openmm.vectorpairii___delslice__(self, *args)
    def __delitem__(self, *args): return _openmm.vectorpairii___delitem__(self, *args)
    def __getitem__(self, *args): return _openmm.vectorpairii___getitem__(self, *args)
    def __setitem__(self, *args): return _openmm.vectorpairii___setitem__(self, *args)
    def append(self, *args): return _openmm.vectorpairii_append(self, *args)
    def empty(self): return _openmm.vectorpairii_empty(self)
    def size(self): return _openmm.vectorpairii_size(self)
    def clear(self): return _openmm.vectorpairii_clear(self)
    def swap(self, *args): return _openmm.vectorpairii_swap(self, *args)
    def get_allocator(self): return _openmm.vectorpairii_get_allocator(self)
    def begin(self): return _openmm.vectorpairii_begin(self)
    def end(self): return _openmm.vectorpairii_end(self)
    def rbegin(self): return _openmm.vectorpairii_rbegin(self)
    def rend(self): return _openmm.vectorpairii_rend(self)
    def pop_back(self): return _openmm.vectorpairii_pop_back(self)
    def erase(self, *args): return _openmm.vectorpairii_erase(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_vectorpairii(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _openmm.vectorpairii_push_back(self, *args)
    def front(self): return _openmm.vectorpairii_front(self)
    def back(self): return _openmm.vectorpairii_back(self)
    def assign(self, *args): return _openmm.vectorpairii_assign(self, *args)
    def resize(self, *args): return _openmm.vectorpairii_resize(self, *args)
    def insert(self, *args): return _openmm.vectorpairii_insert(self, *args)
    def reserve(self, *args): return _openmm.vectorpairii_reserve(self, *args)
    def capacity(self): return _openmm.vectorpairii_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorpairii
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorpairii_swigregister = _openmm.vectorpairii_swigregister
vectorpairii_swigregister(vectorpairii)

class vectorstring(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorstring, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorstring, name)
    __repr__ = _swig_repr
    def iterator(self): return _openmm.vectorstring_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _openmm.vectorstring___nonzero__(self)
    def __bool__(self): return _openmm.vectorstring___bool__(self)
    def __len__(self): return _openmm.vectorstring___len__(self)
    def pop(self): return _openmm.vectorstring_pop(self)
    def __getslice__(self, *args): return _openmm.vectorstring___getslice__(self, *args)
    def __setslice__(self, *args): return _openmm.vectorstring___setslice__(self, *args)
    def __delslice__(self, *args): return _openmm.vectorstring___delslice__(self, *args)
    def __delitem__(self, *args): return _openmm.vectorstring___delitem__(self, *args)
    def __getitem__(self, *args): return _openmm.vectorstring___getitem__(self, *args)
    def __setitem__(self, *args): return _openmm.vectorstring___setitem__(self, *args)
    def append(self, *args): return _openmm.vectorstring_append(self, *args)
    def empty(self): return _openmm.vectorstring_empty(self)
    def size(self): return _openmm.vectorstring_size(self)
    def clear(self): return _openmm.vectorstring_clear(self)
    def swap(self, *args): return _openmm.vectorstring_swap(self, *args)
    def get_allocator(self): return _openmm.vectorstring_get_allocator(self)
    def begin(self): return _openmm.vectorstring_begin(self)
    def end(self): return _openmm.vectorstring_end(self)
    def rbegin(self): return _openmm.vectorstring_rbegin(self)
    def rend(self): return _openmm.vectorstring_rend(self)
    def pop_back(self): return _openmm.vectorstring_pop_back(self)
    def erase(self, *args): return _openmm.vectorstring_erase(self, *args)
    def __init__(self, *args): 
        this = _openmm.new_vectorstring(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _openmm.vectorstring_push_back(self, *args)
    def front(self): return _openmm.vectorstring_front(self)
    def back(self): return _openmm.vectorstring_back(self)
    def assign(self, *args): return _openmm.vectorstring_assign(self, *args)
    def resize(self, *args): return _openmm.vectorstring_resize(self, *args)
    def insert(self, *args): return _openmm.vectorstring_insert(self, *args)
    def reserve(self, *args): return _openmm.vectorstring_reserve(self, *args)
    def capacity(self): return _openmm.vectorstring_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorstring
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorstring_swigregister = _openmm.vectorstring_swigregister
vectorstring_swigregister(vectorstring)

try:
    import numpy
except:
    pass

import math
RMIN_PER_SIGMA=math.pow(2, 1/6.0)
RVDW_PER_SIGMA=math.pow(2, 1/6.0)/2.0

import simtk.unit as unit


class State(_object):
    """
     A State object records a snapshot of the
     current state of a simulation at a point
     in time.  You create it by calling
     getState() on a Context.
     
     When a State is created, you specify what
     information should be stored in it.  This
     saves time and memory by only copying in
     the information that you actually want.
     This is especially important for forces
     and energies, since they may need to be
     calculated.  If you query a State object
     for a piece of information which is not
     available (because it was not requested
     when the State was created), it will
     return None.

     In general return values are Python Units
     (https://simtk.org/home/python_units).
     Among other things Python Units provides a
     container class, Quantity, which holds a
     value and a representation of the value's
     unit.  Values can be integers, floats,
     lists, numarrays, etc.  Quantity objects
     can be used in arithmetic operation just
     like number, except they also keep track
     of units.   To extract the value from a
     quantity, us the value_in_unit() method.
     For example, to extract the value from a
     length quantity, in units of nanometers,
     do the following:
     myLengthQuantity.value_in_unit(unit.nanometer)

"""
    def __init__(self,
                 simTime=None,
                 energy=None,
                 coordList=None,
                 velList=None,
                 forceList=None,
                 periodicBoxVectorsList=None,
                 paramMap=None):
        self._simTime=simTime
        self._periodicBoxVectorsList=periodicBoxVectorsList
        if energy:
            self._eK0=energy[0]
            self._eP0=energy[1]
        else:
            self._eK0=None
            self._eP0=None
        self._coordList=coordList
        self._coordListNumpy=None
        self._velList=velList
        self._velListNumpy=None
        self._forceList=forceList
        self._forceListNumpy=None
        self._paramMap=paramMap

    def getTime(self):
        """Get the time for which this State was created."""
        return self._simTime * unit.picosecond

    def getPeriodicBoxVectors(self, asNumpy=False):
        """Get the three periodic box vectors if this state is from a
           simulation using PBC ."""
        if not self._periodicBoxVectorsList:
            raise TypeError('periodic box vectors were not available.')

        if asNumpy:
            if not self._periodicBoxVectorsListNumpy:
                self._periodicBoxVectorsListNumpy = \
                     numpy.array(self._periodicBoxVectorsList)
            returnValue=self._periodicBoxVectorsListNumpy
        else:
            returnValue=self._periodicBoxVectorsList

        returnValue = unit.Quantity(returnValue, unit.nanometers)
        return returnValue

    def getPositions(self, asNumpy=False):
        """Get the position of each particle with units.
           Raises an exception if postions where not requested in
           the context.getState() call.
           Returns a list of tuples, unless asNumpy is True, in
           which  case a Numpy array of arrays will be returned.
           To remove the units, divide return value by unit.angstrom
           or unit.nanometer.  See the following for details:
           https://simtk.org/home/python_units
           """
        if not self._coordList:
            raise TypeError('Positions were not requested in getState() call, so are not available.')

        if asNumpy:
            if not self._coordListNumpy:
                self._coordListNumpy=numpy.array(self._coordList)
            returnValue=self._coordListNumpy
        else:
            returnValue=self._coordList

        returnValue = unit.Quantity(returnValue, unit.nanometers)
        return returnValue

    def getVelocities(self, asNumpy=False):
        """Get the velocity of each particle with units.
           Raises an exception if velocities where not requested in
           the context.getState() call.
           Returns a list of tuples, unless asNumpy is True, in
           which  case a Numpy array of arrays will be returned.
           To remove the units, you can divide the return value by
           unit.angstrom/unit.picosecond or unit.meter/unit.second,
           etc.  See the following for details:
           https://simtk.org/home/python_units
           """
        if not self._velList:
            raise TypeError('Velocities were not requested in getState() call, so are not available.')

        if asNumpy:
            if not self._velListNumpy:
                self._velListNumpy=numpy.array(self._velList)
            returnValue=self._velListNumpy
        else:
            returnValue=self._velList

        returnValue = unit.Quantity(returnValue, unit.nanometers/unit.picosecond)
        return returnValue

    def getForces(self, asNumpy=False):
        """Get the force acting on each particle with units.
           Raises an exception if forces where not requested in
           the context.getState() call.
           Returns a list of tuples, unless asNumpy is True, in
           which  case a Numpy array of arrays will be returned.
           To remove the units, you can divide the return value by
           unit.kilojoule_per_mole/unit.angstrom or
           unit.calorie_per_mole/unit.nanometer, etc.
           See the following for details:
           https://simtk.org/home/python_units
           """
        if not self._forceList:
            raise TypeError('Forces were not requested in getState() call, so are not available.')

        if asNumpy:
            if not self._forceListNumpy:
                self._forceListNumpy=numpy.array(self._forceList)
            returnValue=self._forceListNumpy
        else:
            returnValue=self._forceList

        returnValue = unit.Quantity(returnValue,
                                    unit.kilojoule_per_mole/unit.nanometer)
        return returnValue

    def getKineticEnergy(self):
        """Get the total kinetic energy of the system with units.
           To remove the units, you can divide the return value by
           unit.kilojoule_per_mole or unit.calorie_per_mole, etc.
           See the following for details:
           https://simtk.org/home/python_units
        """
        return self._eK0 * unit.kilojoule_per_mole

    def getPotentialEnergy(self):
        """Get the total potential energy of the system with units.
           To remove the units, you can divide the return value by
           unit.kilojoule_per_mole or unit.kilocalorie_per_mole, etc.
           See the following for details:
           https://simtk.org/home/python_units
        """
        return self._eP0 * unit.kilojoule_per_mole

    def getParameters(self):
        """Get a map containing the values of all parameters.
        """
        return self._paramMap


# Strings can cause trouble
# as can any container that has infinite levels of containment
def _is_string(x):
     # step 1) String is always a container
     # and its contents are themselves containers.
     try:
         first_item = iter(x).next()
         inner_item = iter(first_item).next()
         if first_item == inner_item:
             return True
         else:
             return False
     except TypeError:
         return False
     except StopIteration:
         return False

def stripUnits(args):
    """
    getState(self, quantity) 
          -> value with *no* units

    Examples
    >>> import simtk

    >>> x = 5
    >>> print x
    5

    >>> x = stripUnits((5*simtk.unit.nanometer,))
    >>> x
    (5,)

    >>> arg1 = 5*simtk.unit.angstrom
    >>> x = stripUnits((arg1,))
    >>> x
    (0.5,)

    >>> arg1 = 5
    >>> x = stripUnits((arg1,))
    >>> x
    (5,)

    >>> arg1 = (1*simtk.unit.angstrom, 5*simtk.unit.angstrom)
    >>> x = stripUnits((arg1,))
    >>> x
    ((0.10000000000000001, 0.5),)

    >>> arg1 = (1*simtk.unit.angstrom,
    ...         5*simtk.unit.kilojoule_per_mole,
    ...         1*simtk.unit.kilocalorie_per_mole)
    >>> y = stripUnits((arg1,))
    >>> y
    ((0.10000000000000001, 5, 4.1840000000000002),)

    """
    newArgList=[]
    for arg in args:
        if unit.is_quantity(arg):
	    # JDC: Ugly workaround for OpenMM using 'bar' for fundamental pressure unit.
            if arg.unit.is_compatible(unit.bar):
	        arg = arg / unit.bar
            else:
                arg=arg.value_in_unit_system(unit.md_unit_system)                
            # JDC: End workaround.
            #arg=arg.value_in_unit_system(unit.md_unit_system)
        elif not _is_string(arg):
            try:
                iter(arg)
                # Reclusively strip units from all quantities
                arg=stripUnits(arg)
            except TypeError:
                pass
        newArgList.append(arg)
    return tuple(newArgList)

class Force(_object):
    """Proxy of C++ OpenMM::Force class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Force, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Force, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Force
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Force_swigregister = _openmm.Force_swigregister
Force_swigregister(Force)
NmPerAngstrom = cvar.NmPerAngstrom
AngstromsPerNm = cvar.AngstromsPerNm
PsPerFs = cvar.PsPerFs
FsPerPs = cvar.FsPerPs
KJPerKcal = cvar.KJPerKcal
KcalPerKJ = cvar.KcalPerKJ
RadiansPerDegree = cvar.RadiansPerDegree
DegreesPerRadian = cvar.DegreesPerRadian
SigmaPerVdwRadius = cvar.SigmaPerVdwRadius
VdwRadiusPerSigma = cvar.VdwRadiusPerSigma

class AmoebaGeneralizedKirkwoodForce(Force):
    """Proxy of C++ OpenMM::AmoebaGeneralizedKirkwoodForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaGeneralizedKirkwoodForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaGeneralizedKirkwoodForce, name)
    __repr__ = _swig_repr
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles in the system.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_getNumParticles(self)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double radius, double scalingFactor) -> int

        Add the parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the force field parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.dimensionless)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double radius, double scalingFactor)

        Set the force field parameters for a particle.
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setParticleParameters(self, *args)

    def getSolventDielectric(self):
        """
        getSolventDielectric(self) -> double

        Get the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getSolventDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(self, double dielectric)

        Set the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setSolventDielectric(self, *args)

    def getSoluteDielectric(self):
        """
        getSoluteDielectric(self) -> double

        Get the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getSoluteDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(self, double dielectric)

        Set the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setSoluteDielectric(self, *args)

    def getDielectricOffset(self):
        """
        getDielectricOffset(self) -> double

        Get the dielectric offset (nm) used in OBC
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getDielectricOffset(self)
        val=unit.Quantity(val, unit.nanometer)


        return val

    def setDielectricOffset(self, *args):
        """
        setDielectricOffset(self, double dielectricOffset)

        Set the dielectric offset (nm) used in OBC
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setDielectricOffset(self, *args)

    def getIncludeCavityTerm(self):
        """
        getIncludeCavityTerm(self) -> int

        Get the flag signalling whether the cavity term should be included
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_getIncludeCavityTerm(self)

    def setIncludeCavityTerm(self, *args):
        """
        setIncludeCavityTerm(self, int includeCavityTerm)

        Set the flag signalling whether the cavity term should be included
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setIncludeCavityTerm(self, *args)

    def getProbeRadius(self):
        """
        getProbeRadius(self) -> double

        Get the probe radius (nm) used in SASA contribution
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getProbeRadius(self)
        val=unit.Quantity(val, unit.nanometer)


        return val

    def setProbeRadius(self, *args):
        """
        setProbeRadius(self, double probeRadius)

        Set the probe radius (nm) used in SASA contribution
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setProbeRadius(self, *args)

    def getSurfaceAreaFactor(self):
        """
        getSurfaceAreaFactor(self) -> double

        Get the surface area factor kJ/(nm*nm) used in SASA contribution
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getSurfaceAreaFactor(self)
        val=unit.Quantity(val, (unit.nanometer*unit.nanometer)/unit.kilojoule_per_mole)


        return val

    def setSurfaceAreaFactor(self, *args):
        """
        setSurfaceAreaFactor(self, double surfaceAreaFactor)

        Set the surface area factor kJ/(nm*nm) used in SASA contribution
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setSurfaceAreaFactor(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaGeneralizedKirkwoodForce
        __init__(self, AmoebaGeneralizedKirkwoodForce other) -> AmoebaGeneralizedKirkwoodForce
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaGeneralizedKirkwoodForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaGeneralizedKirkwoodForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaGeneralizedKirkwoodForce_swigregister = _openmm.AmoebaGeneralizedKirkwoodForce_swigregister
AmoebaGeneralizedKirkwoodForce_swigregister(AmoebaGeneralizedKirkwoodForce)

class AmoebaHarmonicAngleForce(Force):
    """Proxy of C++ OpenMM::AmoebaHarmonicAngleForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaHarmonicAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaHarmonicAngleForce, name)
    __repr__ = _swig_repr
    def getNumAngles(self):
        """
        getNumAngles(self) -> int

        Get the number of harmonic angle stretch terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_getNumAngles(self)

    def setAmoebaGlobalHarmonicAngleCubic(self, *args):
        """
        setAmoebaGlobalHarmonicAngleCubic(self, double cubicK)

        Set the global cubic term
           cubicK -- the cubic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_setAmoebaGlobalHarmonicAngleCubic(self, *args)

    def getAmoebaGlobalHarmonicAngleCubic(self):
        """
        getAmoebaGlobalHarmonicAngleCubic(self) -> double

        Get the global cubic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_getAmoebaGlobalHarmonicAngleCubic(self)

    def setAmoebaGlobalHarmonicAngleQuartic(self, *args):
        """
        setAmoebaGlobalHarmonicAngleQuartic(self, double quarticK)

        Set the global cubic term
           quarticK -- the quartic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_setAmoebaGlobalHarmonicAngleQuartic(self, *args)

    def getAmoebaGlobalHarmonicAngleQuartic(self):
        """
        getAmoebaGlobalHarmonicAngleQuartic(self) -> double

        Get the global quartic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_getAmoebaGlobalHarmonicAngleQuartic(self)

    def setAmoebaGlobalHarmonicAnglePentic(self, *args):
        """
        setAmoebaGlobalHarmonicAnglePentic(self, double penticK)

        Set the global pentic term
           penticK -- the pentic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_setAmoebaGlobalHarmonicAnglePentic(self, *args)

    def getAmoebaGlobalHarmonicAnglePentic(self):
        """
        getAmoebaGlobalHarmonicAnglePentic(self) -> double

        Get the global pentic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_getAmoebaGlobalHarmonicAnglePentic(self)

    def setAmoebaGlobalHarmonicAngleSextic(self, *args):
        """
        setAmoebaGlobalHarmonicAngleSextic(self, double sexticK)

        Set the global sextic term
           sexticK -- the sextic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_setAmoebaGlobalHarmonicAngleSextic(self, *args)

    def getAmoebaGlobalHarmonicAngleSextic(self):
        """
        getAmoebaGlobalHarmonicAngleSextic(self) -> double

        Get the global sextic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_getAmoebaGlobalHarmonicAngleSextic(self)

    def addAngle(self, *args):
        """
        addAngle(self, int particle1, int particle2, int particle3, double length, 
            double quadraticK) -> int

        Add a angle term to the force field.
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           length -- the angle measured in radians
           quadratic -- k the quadratic harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_addAngle(self, *args)

    def getAngleParameters(self, *args):
        """
        getAngleParameters(self, int index)

        Get the force field parameters for a angle term.
           index -- the index of the angle for which to get parameters
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           length -- the equilibrium angle, measured in radians
           quadratic -- k the quadratic harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaHarmonicAngleForce_getAngleParameters(self, *args)
        val[3]=unit.Quantity(val[3], unit.radian)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole/(unit.radian*unit.radian))


        return val

    def setAngleParameters(self, *args):
        """
        setAngleParameters(self, int index, int particle1, int particle2, int particle3, 
            double length, double quadraticK)

        Set the force field parameters for a angle term.
           index -- the index of the angle for which to set parameters
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           length -- the equilibrium angle, measured in radians
           quadratic -- k the quadratic harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicAngleForce_setAngleParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaHarmonicAngleForce
        __init__(self, AmoebaHarmonicAngleForce other) -> AmoebaHarmonicAngleForce

        Create a Amoeba HarmonicAngleForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaHarmonicAngleForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaHarmonicAngleForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaHarmonicAngleForce_swigregister = _openmm.AmoebaHarmonicAngleForce_swigregister
AmoebaHarmonicAngleForce_swigregister(AmoebaHarmonicAngleForce)

class AmoebaHarmonicBondForce(Force):
    """Proxy of C++ OpenMM::AmoebaHarmonicBondForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaHarmonicBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaHarmonicBondForce, name)
    __repr__ = _swig_repr
    def getNumBonds(self):
        """
        getNumBonds(self) -> int

        Get the number of harmonic bond stretch terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_getNumBonds(self)

    def setAmoebaGlobalHarmonicBondCubic(self, *args):
        """
        setAmoebaGlobalHarmonicBondCubic(self, double cubicK)

        Set the global cubic term
           cubicK -- the cubic harmonic force constant for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_setAmoebaGlobalHarmonicBondCubic(self, *args)

    def getAmoebaGlobalHarmonicBondCubic(self):
        """
        getAmoebaGlobalHarmonicBondCubic(self) -> double

        Get the global cubic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_getAmoebaGlobalHarmonicBondCubic(self)

    def setAmoebaGlobalHarmonicBondQuartic(self, *args):
        """
        setAmoebaGlobalHarmonicBondQuartic(self, double quarticK)

        Set the global cubic term
           quarticK -- the quartic harmonic force constant for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_setAmoebaGlobalHarmonicBondQuartic(self, *args)

    def getAmoebaGlobalHarmonicBondQuartic(self):
        """
        getAmoebaGlobalHarmonicBondQuartic(self) -> double

        Get the global quartic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_getAmoebaGlobalHarmonicBondQuartic(self)

    def addBond(self, *args):
        """
        addBond(self, int particle1, int particle2, double length, double quadraticK) -> int

        Add a bond term to the force field.
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           length -- the equilibrium length of the bond, measured in nm
           k -- the quadratic harmonic force constant for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_addBond(self, *args)

    def getBondParameters(self, *args):
        """
        getBondParameters(self, int index)

        Get the force field parameters for a bond term.
           index -- the index of the bond for which to get parameters
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           length -- the equilibrium length of the bond, measured in nm
           quadratic -- k the quadratic harmonic force constant for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaHarmonicBondForce_getBondParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)
        val[3]=unit.Quantity(val[3], unit.kilojoule_per_mole/(unit.nanometer*unit.nanometer))


        return val

    def setBondParameters(self, *args):
        """
        setBondParameters(self, int index, int particle1, int particle2, double length, 
            double quadraticK)

        Set the force field parameters for a bond term.
           index -- the index of the bond for which to set parameters
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           length -- the equilibrium length of the bond, measured in nm
           k -- the quadratic harmonic force constant for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicBondForce_setBondParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaHarmonicBondForce
        __init__(self, AmoebaHarmonicBondForce other) -> AmoebaHarmonicBondForce

        Create a Amoeba HarmonicBondForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaHarmonicBondForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaHarmonicBondForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaHarmonicBondForce_swigregister = _openmm.AmoebaHarmonicBondForce_swigregister
AmoebaHarmonicBondForce_swigregister(AmoebaHarmonicBondForce)

class AmoebaHarmonicInPlaneAngleForce(Force):
    """Proxy of C++ OpenMM::AmoebaHarmonicInPlaneAngleForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaHarmonicInPlaneAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaHarmonicInPlaneAngleForce, name)
    __repr__ = _swig_repr
    def getNumAngles(self):
        """
        getNumAngles(self) -> int

        Get the number of harmonic angle stretch terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_getNumAngles(self)

    def setAmoebaGlobalHarmonicInPlaneAngleCubic(self, *args):
        """
        setAmoebaGlobalHarmonicInPlaneAngleCubic(self, double cubicK)

        Set the global cubic term
           cubicK -- the cubic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_setAmoebaGlobalHarmonicInPlaneAngleCubic(self, *args)

    def getAmoebaGlobalHarmonicInPlaneAngleCubic(self):
        """
        getAmoebaGlobalHarmonicInPlaneAngleCubic(self) -> double

        Get the global cubic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_getAmoebaGlobalHarmonicInPlaneAngleCubic(self)

    def setAmoebaGlobalHarmonicInPlaneAngleQuartic(self, *args):
        """
        setAmoebaGlobalHarmonicInPlaneAngleQuartic(self, double quarticK)

        Set the global quartic term
           quarticK -- the quartic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_setAmoebaGlobalHarmonicInPlaneAngleQuartic(self, *args)

    def getAmoebaGlobalHarmonicInPlaneAngleQuartic(self):
        """
        getAmoebaGlobalHarmonicInPlaneAngleQuartic(self) -> double

        Get the global quartic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_getAmoebaGlobalHarmonicInPlaneAngleQuartic(self)

    def setAmoebaGlobalHarmonicInPlaneAnglePentic(self, *args):
        """
        setAmoebaGlobalHarmonicInPlaneAnglePentic(self, double penticK)

        Set the global pentic term
           penticK -- the pentic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_setAmoebaGlobalHarmonicInPlaneAnglePentic(self, *args)

    def getAmoebaGlobalHarmonicInPlaneAnglePentic(self):
        """
        getAmoebaGlobalHarmonicInPlaneAnglePentic(self) -> double

        Get the global pentic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_getAmoebaGlobalHarmonicInPlaneAnglePentic(self)

    def setAmoebaGlobalHarmonicInPlaneAngleSextic(self, *args):
        """
        setAmoebaGlobalHarmonicInPlaneAngleSextic(self, double sexticK)

        Set the global sextic term
           sexticK -- the sextic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_setAmoebaGlobalHarmonicInPlaneAngleSextic(self, *args)

    def getAmoebaGlobalHarmonicInPlaneAngleSextic(self):
        """
        getAmoebaGlobalHarmonicInPlaneAngleSextic(self) -> double

        Get the global sextic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_getAmoebaGlobalHarmonicInPlaneAngleSextic(self)

    def addAngle(self, *args):
        """
        addAngle(self, int particle1, int particle2, int particle3, int particle4, 
            double length, double quadraticK) -> int

        Add a angle term to the force field.
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           particle4 -- the index of the fourth particle connected by the angle
           length -- the equilibrium angle, measured in radians
           quadratic -- k the quadratic harmonic force constant for the angle measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_addAngle(self, *args)

    def getAngleParameters(self, *args):
        """
        getAngleParameters(self, int index)

        Get the force field parameters for a angle term.
           index -- the index of the angle for which to get parameters
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           particle4 -- the index of the fourth particle connected by the angle
           length -- the equilibrium angle, measured in radians
           quadratic -- k the quadratic harmonic force constant for the angle measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaHarmonicInPlaneAngleForce_getAngleParameters(self, *args)
        val[4]=unit.Quantity(val[4], unit.radian)
        val[5]=unit.Quantity(val[5], unit.kilojoule_per_mole/(unit.radian*unit.radian))


        return val

    def setAngleParameters(self, *args):
        """
        setAngleParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, double length, double quadraticK)

        Set the force field parameters for a angle term.
           index -- the index of the angle for which to set parameters
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           particle4 -- the index of the fourth particle connected by the angle
           length -- the equilibrium angle, measured in radians
           quadratic -- k the quadratic harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaHarmonicInPlaneAngleForce_setAngleParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaHarmonicInPlaneAngleForce
        __init__(self, AmoebaHarmonicInPlaneAngleForce other) -> AmoebaHarmonicInPlaneAngleForce

        Create a Amoeba HarmonicAngleForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaHarmonicInPlaneAngleForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaHarmonicInPlaneAngleForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaHarmonicInPlaneAngleForce_swigregister = _openmm.AmoebaHarmonicInPlaneAngleForce_swigregister
AmoebaHarmonicInPlaneAngleForce_swigregister(AmoebaHarmonicInPlaneAngleForce)

class AmoebaMultipoleForce(Force):
    """Proxy of C++ OpenMM::AmoebaMultipoleForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaMultipoleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaMultipoleForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.AmoebaMultipoleForce_NoCutoff
    PME = _openmm.AmoebaMultipoleForce_PME
    ZThenX = _openmm.AmoebaMultipoleForce_ZThenX
    Bisector = _openmm.AmoebaMultipoleForce_Bisector
    ZBisect = _openmm.AmoebaMultipoleForce_ZBisect
    ThreeFold = _openmm.AmoebaMultipoleForce_ThreeFold
    ZOnly = _openmm.AmoebaMultipoleForce_ZOnly
    LastAxisTypeIndex = _openmm.AmoebaMultipoleForce_LastAxisTypeIndex
    SOR = _openmm.AmoebaMultipoleForce_SOR
    Covalent12 = _openmm.AmoebaMultipoleForce_Covalent12
    Covalent13 = _openmm.AmoebaMultipoleForce_Covalent13
    Covalent14 = _openmm.AmoebaMultipoleForce_Covalent14
    Covalent15 = _openmm.AmoebaMultipoleForce_Covalent15
    PolarizationCovalent11 = _openmm.AmoebaMultipoleForce_PolarizationCovalent11
    PolarizationCovalent12 = _openmm.AmoebaMultipoleForce_PolarizationCovalent12
    PolarizationCovalent13 = _openmm.AmoebaMultipoleForce_PolarizationCovalent13
    PolarizationCovalent14 = _openmm.AmoebaMultipoleForce_PolarizationCovalent14
    CovalentEnd = _openmm.AmoebaMultipoleForce_CovalentEnd
    def getNumMultipoles(self):
        """
        getNumMultipoles(self) -> int

        Get the number of particles in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getNumMultipoles(self)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> AmoebaNonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, AmoebaNonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getCutoffDistance(self)

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setCutoffDistance(self, *args)

    def getAEwald(self):
        """
        getAEwald(self) -> double

        Get the aEwald parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaMultipoleForce_getAEwald(self)
        val=unit.Quantity(val, 1/unit.nanometer)


        return val

    def setAEwald(self, *args):
        """
        setAEwald(self, double aewald)

        Set the aEwald parameter
           Ewald -- parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setAEwald(self, *args)

    def getPmeBSplineOrder(self):
        """
        getPmeBSplineOrder(self) -> int

        Get the B-spline order parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getPmeBSplineOrder(self)

    def setPmeBSplineOrder(self, *args):
        """
        setPmeBSplineOrder(self, int inputBSplineOrder)

        Set the B-spline order parameter
           the -- B-spline order parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setPmeBSplineOrder(self, *args)

    def getPmeGridDimensions(self):
        """
        getPmeGridDimensions(self)

        Get the PME grid dimensions
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getPmeGridDimensions(self)

    def setPmeGridDimensions(self, *args):
        """
        setPmeGridDimensions(self, vectori gridDimension)

        Set the PME grid dimensions
           the -- PME grid dimensions
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setPmeGridDimensions(self, *args)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, vectord molecularDipole, vectord molecularQuadrupole, 
            int axisType, int multipoleAtomZ, 
            int multipoleAtomX, int multipoleAtomY, 
            double thole, double dampingFactor, double polarity) -> int

        Add multipole-related info for a particle
           charge -- the particle's charge
           molecularDipole -- the particle's molecular dipole (vector of size 3)
           molecularQuadrupole -- the particle's molecular quadrupole (vector of size 9)
           axisType -- the particle's axis type ( ZThenX, Bisector )
           multipoleAtomZ -- index of first atom used in constructing lab<->molecular frames
           multipoleAtomX -- index of second atom used in constructing lab<->molecular frames
           multipoleAtomY -- index of second atom used in constructing lab<->molecular frames
           thole -- Thole parameter
           dampingFactor -- dampingFactor parameter
           polarity -- polarity parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_addParticle(self, *args)

    def getMultipoleParameters(self, *args):
        """
        getMultipoleParameters(self, int index)

        Get the multipole parameters for a particle.
           index -- the index of the atom for which to get parameters
           charge -- the particle's charge
           molecularDipole -- the particle's molecular dipole (vector of size 3)
           molecularQuadrupole -- the particle's molecular quadrupole (vector of size 9)
           axisType -- the particle's axis type ( ZThenX, Bisector )
           multipoleAtomZ -- index of first atom used in constructing lab<->molecular frames
           multipoleAtomX -- index of second atom used in constructing lab<->molecular frames
           multipoleAtomY -- index of second atom used in constructing lab<->molecular frames
           thole -- Thole parameter
           dampingFactor -- dampingFactor parameter
           polarity -- polarity parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMultipoleParameters(self, *args)

    def setMultipoleParameters(self, *args):
        """
        setMultipoleParameters(self, int index, double charge, int axisType, int multipoleAtomZ, 
            int multipoleAtomX, int multipoleAtomY, 
            double thole, double dampingFactor, double polarity)

        Set the multipole parameters for a particle.
           index -- the index of the atom for which to set parameters
           charge -- the particle's charge
           molecularDipole -- the particle's molecular dipole (vector of size 3)
           molecularQuadrupole -- the particle's molecular quadrupole (vector of size 9)
           axisType -- the particle's axis type ( ZThenX, Bisector )
           multipoleAtomZ -- index of first atom used in constructing lab<->molecular frames
           multipoleAtomX -- index of second atom used in constructing lab<->molecular frames
           multipoleAtomY -- index of second atom used in constructing lab<->molecular frames
           polarity -- polarity parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMultipoleParameters(self, *args)

    def setCovalentMap(self, *args):
        """
        setCovalentMap(self, int index, CovalentType typeId, vectori covalentAtoms)

        Set the CovalentMap for an atom
           index -- the index of the atom for which to set parameters
           typeId -- CovalentTypes type
           covalentAtoms -- vector of covalent atoms associated w/ the specfied CovalentType
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setCovalentMap(self, *args)

    def getCovalentMap(self, *args):
        """
        getCovalentMap(self, int index, CovalentType typeId)

        Get the CovalentMap for an atom
           index -- the index of the atom for which to set parameters
           typeId -- CovalentTypes type
           covalentAtoms -- output vector of covalent atoms associated w/ the specfied CovalentType
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getCovalentMap(self, *args)

    def getCovalentMaps(self, *args):
        """
        getCovalentMaps(self, int index)

        Get the CovalentMap for an atom
           index -- the index of the atom for which to set parameters
           covalentLists -- output vector of covalent lists of atoms
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getCovalentMaps(self, *args)

    def getMutualInducedIterationMethod(self):
        """
        getMutualInducedIterationMethod(self) -> MutualInducedIterationMethod

        Get the iteration method to be used for calculating the mutual induced dipoles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMutualInducedIterationMethod(self)

    def setMutualInducedIterationMethod(self, *args):
        """
        setMutualInducedIterationMethod(self, MutualInducedIterationMethod inputMutualInducedIterationMethod)

        Set the iteration method to be used for calculating the mutual induced dipoles
           iteration -- method to be used for calculating the mutual induced dipole
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMutualInducedIterationMethod(self, *args)

    def getMutualInducedMaxIterations(self):
        """
        getMutualInducedMaxIterations(self) -> int

        Get the max number of iterations to be used in calculating the mutual induced dipoles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMutualInducedMaxIterations(self)

    def setMutualInducedMaxIterations(self, *args):
        """
        setMutualInducedMaxIterations(self, int inputMutualInducedMaxIterations)

        Set the max number of iterations to be used in calculating the mutual induced dipoles
           max -- number of iterations
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMutualInducedMaxIterations(self, *args)

    def getMutualInducedTargetEpsilon(self):
        """
        getMutualInducedTargetEpsilon(self) -> double

        Get the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMutualInducedTargetEpsilon(self)

    def setMutualInducedTargetEpsilon(self, *args):
        """
        setMutualInducedTargetEpsilon(self, double inputMutualInducedTargetEpsilon)

        Set the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles
           target -- epsilon
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMutualInducedTargetEpsilon(self, *args)

    def getScalingDistanceCutoff(self):
        """
        getScalingDistanceCutoff(self) -> double

        Get the scaling distance cutoff (nm)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getScalingDistanceCutoff(self)

    def setScalingDistanceCutoff(self, *args):
        """
        setScalingDistanceCutoff(self, double inputScalingDistanceCutoff)

        Set the scaling distance cutoff
           scaling -- distance cutoff
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setScalingDistanceCutoff(self, *args)

    def getElectricConstant(self):
        """
        getElectricConstant(self) -> double

        Get the electric constant
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getElectricConstant(self)

    def setElectricConstant(self, *args):
        """
        setElectricConstant(self, double inputElectricConstant)

        Set the electric constant
           the -- electric constant
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setElectricConstant(self, *args)

    def getEwaldErrorTolerance(self):
        """
        getEwaldErrorTolerance(self) -> double

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getEwaldErrorTolerance(self)

    def setEwaldErrorTolerance(self, *args):
        """
        setEwaldErrorTolerance(self, double tol)

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setEwaldErrorTolerance(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaMultipoleForce
        __init__(self, AmoebaMultipoleForce other) -> AmoebaMultipoleForce

        Create a Amoeba MultipoleForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaMultipoleForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaMultipoleForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaMultipoleForce_swigregister = _openmm.AmoebaMultipoleForce_swigregister
AmoebaMultipoleForce_swigregister(AmoebaMultipoleForce)

class AmoebaOutOfPlaneBendForce(Force):
    """Proxy of C++ OpenMM::AmoebaOutOfPlaneBendForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaOutOfPlaneBendForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaOutOfPlaneBendForce, name)
    __repr__ = _swig_repr
    def getNumOutOfPlaneBends(self):
        """
        getNumOutOfPlaneBends(self) -> int

        Get the number of outOfPlaneBend terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getNumOutOfPlaneBends(self)

    def setAmoebaGlobalOutOfPlaneBendCubic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendCubic(self, double cubicK)

        Set the global cubic term
           cubicK -- the cubic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendCubic(self, *args)

    def getAmoebaGlobalOutOfPlaneBendCubic(self):
        """
        getAmoebaGlobalOutOfPlaneBendCubic(self) -> double

        Get the global cubic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendCubic(self)

    def setAmoebaGlobalOutOfPlaneBendQuartic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendQuartic(self, double quarticK)

        Set the global cubic term
           quarticK -- the quartic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendQuartic(self, *args)

    def getAmoebaGlobalOutOfPlaneBendQuartic(self):
        """
        getAmoebaGlobalOutOfPlaneBendQuartic(self) -> double

        Get the global quartic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendQuartic(self)

    def setAmoebaGlobalOutOfPlaneBendPentic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendPentic(self, double penticK)

        Set the global pentic term
           penticK -- the pentic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendPentic(self, *args)

    def getAmoebaGlobalOutOfPlaneBendPentic(self):
        """
        getAmoebaGlobalOutOfPlaneBendPentic(self) -> double

        Get the global pentic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendPentic(self)

    def setAmoebaGlobalOutOfPlaneBendSextic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendSextic(self, double sexticK)

        Set the global sextic term
           sexticK -- the sextic harmonic force constant for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendSextic(self, *args)

    def getAmoebaGlobalOutOfPlaneBendSextic(self):
        """
        getAmoebaGlobalOutOfPlaneBendSextic(self) -> double

        Get the global sextic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendSextic(self)

    def addOutOfPlaneBend(self, *args):
        """
        addOutOfPlaneBend(self, int particle1, int particle2, int particle3, int particle4, 
            double k) -> int

        Add a outOfPlaneBend term to the force field.
           particle1 -- the index of the first particle connected by the outOfPlaneBend
           particle2 -- the index of the second particle connected by the outOfPlaneBend
           particle3 -- the index of the third particle connected by the outOfPlaneBend
           particle4 -- the index of the fourth particle connected by the outOfPlaneBend
           k -- the force constant for the outOfPlaneBend
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_addOutOfPlaneBend(self, *args)

    def getOutOfPlaneBendParameters(self, *args):
        """
        getOutOfPlaneBendParameters(self, int index)

        Get the force field parameters for a outOfPlaneBend term.
           index -- the index of the outOfPlaneBend for which to get parameters
           particle1 -- the index of the first particle connected by the outOfPlaneBend
           particle2 -- the index of the second particle connected by the outOfPlaneBend
           particle3 -- the index of the third particle connected by the outOfPlaneBend
           particle4 -- the index of the fourth particle connected by the outOfPlaneBend
           k -- the force constant for the outOfPlaneBend
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaOutOfPlaneBendForce_getOutOfPlaneBendParameters(self, *args)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole)


        return val

    def setOutOfPlaneBendParameters(self, *args):
        """
        setOutOfPlaneBendParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, double k)

        Set the force field parameters for a outOfPlaneBend term.
           index -- the index of the outOfPlaneBend for which to set parameters
           particle1 -- the index of the first particle connected by the outOfPlaneBend
           particle2 -- the index of the second particle connected by the outOfPlaneBend
           particle3 -- the index of the third particle connected by the outOfPlaneBend
           particle4 -- the index of the fourth particle connected by the outOfPlaneBend
           k -- the force constant for the outOfPlaneBend
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setOutOfPlaneBendParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaOutOfPlaneBendForce
        __init__(self, AmoebaOutOfPlaneBendForce other) -> AmoebaOutOfPlaneBendForce

        Create a Amoeba OutOfPlaneBendForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaOutOfPlaneBendForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaOutOfPlaneBendForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaOutOfPlaneBendForce_swigregister = _openmm.AmoebaOutOfPlaneBendForce_swigregister
AmoebaOutOfPlaneBendForce_swigregister(AmoebaOutOfPlaneBendForce)

class AmoebaPiTorsionForce(Force):
    """Proxy of C++ OpenMM::AmoebaPiTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaPiTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaPiTorsionForce, name)
    __repr__ = _swig_repr
    def getNumPiTorsions(self):
        """
        getNumPiTorsions(self) -> int

        Get the number of pi torsion terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_getNumPiTorsions(self)

    def addPiTorsion(self, *args):
        """
        addPiTorsion(self, int particle1, int particle2, int particle3, int particle4, 
            int particle5, int particle6, double k) -> int

        Add a torsion term to the force field.
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           particle5 -- the index of the fifth particle connected by the torsion
           particle6 -- the index of the sixth particle connected by the torsion
           k -- the force constant for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_addPiTorsion(self, *args)

    def getPiTorsionParameters(self, *args):
        """
        getPiTorsionParameters(self, int index)

        Get the force field parameters for a torsion term.
           index -- the index of the torsion for which to get parameters
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           particle5 -- the index of the fifth particle connected by the torsion
           particle6 -- the index of the sixth particle connected by the torsion
           k -- the force constant for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaPiTorsionForce_getPiTorsionParameters(self, *args)
        val[6]=unit.Quantity(val[6], unit.kilojoule_per_mole)


        return val

    def setPiTorsionParameters(self, *args):
        """
        setPiTorsionParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, int particle5, int particle6, 
            double k)

        Set the force field parameters for a pi torsion term.
           index -- the index of the torsion for which to set parameters
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           particle5 -- the index of the fifth particle connected by the torsion
           particle6 -- the index of the sixth particle connected by the torsion
           k -- the force constant for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_setPiTorsionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaPiTorsionForce
        __init__(self, AmoebaPiTorsionForce other) -> AmoebaPiTorsionForce

        Create a Amoeba PiTorsionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaPiTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaPiTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaPiTorsionForce_swigregister = _openmm.AmoebaPiTorsionForce_swigregister
AmoebaPiTorsionForce_swigregister(AmoebaPiTorsionForce)

class AmoebaStretchBendForce(Force):
    """Proxy of C++ OpenMM::AmoebaStretchBendForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaStretchBendForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaStretchBendForce, name)
    __repr__ = _swig_repr
    def getNumStretchBends(self):
        """
        getNumStretchBends(self) -> int

        Get the number of stretchBend terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_getNumStretchBends(self)

    def addStretchBend(self, *args):
        """
        addStretchBend(self, int particle1, int particle2, int particle3, double lengthAB, 
            double lengthCB, double angle, double k) -> int

        Add a stretchBend term to the force field.
           particle1 -- the index of the first particle connected by the stretchBend
           particle2 -- the index of the second particle connected by the stretchBend
           particle3 -- the index of the third particle connected by the stretchBend
           lengthAB -- the equilibrium length of the stretchBend in bond ab [particle1, particle2], measured in nm
           lengthCB -- the equilibrium length of the stretchBend in bond cb [particle3, particle2], measured in nm
           angle -- the equilibrium angle in radians
           k -- the force constant for the stretchBend
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_addStretchBend(self, *args)

    def getStretchBendParameters(self, *args):
        """
        getStretchBendParameters(self, int index)

        Get the force field parameters for a stretchBend term.
           index -- the index of the stretchBend for which to get parameters
           particle1 -- the index of the first particle connected by the stretchBend
           particle2 -- the index of the second particle connected by the stretchBend
           particle3 -- the index of the third particle connected by the stretchBend
           lengthAB -- the equilibrium length of the stretchBend in bond ab [particle1, particle2], measured in nm
           lengthCB -- the equilibrium length of the stretchBend in bond cb [particle3, particle2], measured in nm
           angle -- the equilibrium angle in radians
           k -- the force constant for the stretchBend
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaStretchBendForce_getStretchBendParameters(self, *args)
        val[3]=unit.Quantity(val[3], unit.nanometer)
        val[4]=unit.Quantity(val[4], unit.nanometer)
        val[5]=unit.Quantity(val[5], unit.radian)
        val[6]=unit.Quantity(val[6], unit.kilojoule_per_mole/unit.nanometer)


        return val

    def setStretchBendParameters(self, *args):
        """
        setStretchBendParameters(self, int index, int particle1, int particle2, int particle3, 
            double lengthAB, double lengthCB, double angle, 
            double k)

        Set the force field parameters for a stretchBend term.
           index -- the index of the stretchBend for which to set parameters
           particle1 -- the index of the first particle connected by the stretchBend
           particle2 -- the index of the second particle connected by the stretchBend
           particle3 -- the index of the third particle connected by the stretchBend
           lengthAB -- the equilibrium length of the stretchBend in bond ab [particle1, particle2], measured in nm
           lengthCB -- the equilibrium length of the stretchBend in bond cb [particle3, particle2], measured in nm
           angle -- the equilibrium angle in radians
           k -- the force constant for the stretchBend
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_setStretchBendParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaStretchBendForce
        __init__(self, AmoebaStretchBendForce other) -> AmoebaStretchBendForce

        Create a Amoeba StretchBendForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaStretchBendForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaStretchBendForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaStretchBendForce_swigregister = _openmm.AmoebaStretchBendForce_swigregister
AmoebaStretchBendForce_swigregister(AmoebaStretchBendForce)

class AmoebaTorsionForce(Force):
    """Proxy of C++ OpenMM::AmoebaTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaTorsionForce, name)
    __repr__ = _swig_repr
    def getNumTorsions(self):
        """
        getNumTorsions(self) -> int

        Get the number of torsion terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionForce_getNumTorsions(self)

    def addTorsion(self, *args):
        """
        addTorsion(self, int particle1, int particle2, int particle3, int particle4, 
            vectord torsion1, vectord torsion2, 
            vectord torsion3) -> int

        Add a torsion term to the force field.
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           torsion1 -- the vector of torsion params for first index (amplitude, phase, fold)
           torsion2 -- the vector of torsion params for second index (amplitude, phase, fold)
           torsion3 -- the vector of torsion params for third index (amplitude, phase, fold)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionForce_addTorsion(self, *args)

    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(self, int index)

        Get the force field parameters for a torsion term.
           index -- the index of the torsion for which to get parameters
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           torsion1 -- the vector of torsion params for first index (amplitude, phase, fold)
           torsion2 -- the vector of torsion params for second index (amplitude, phase, fold)
           torsion3 -- the vector of torsion params for third index (amplitude, phase, fold)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionForce_getTorsionParameters(self, *args)

    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4)

        Set the force field parameters for a torsion term.
           index -- the index of the torsion for which to set parameters
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           torsion1 -- the vector of torsion params for first index (amplitude, phase, fold)
           torsion2 -- the vector of torsion params for second index (amplitude, phase, fold)
           torsion3 -- the vector of torsion params for third index (amplitude, phase, fold)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionForce_setTorsionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaTorsionForce
        __init__(self, AmoebaTorsionForce other) -> AmoebaTorsionForce

        Create a Amoeba TorsionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaTorsionForce_swigregister = _openmm.AmoebaTorsionForce_swigregister
AmoebaTorsionForce_swigregister(AmoebaTorsionForce)

class AmoebaTorsionTorsionForce(Force):
    """Proxy of C++ OpenMM::AmoebaTorsionTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaTorsionTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaTorsionTorsionForce, name)
    __repr__ = _swig_repr
    def getNumTorsionTorsions(self):
        """
        getNumTorsionTorsions(self) -> int

        Get the number of torsionTorsion terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getNumTorsionTorsions(self)

    def getNumTorsionTorsionGrids(self):
        """
        getNumTorsionTorsionGrids(self) -> int

        Get the number of torsionTorsion grids
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getNumTorsionTorsionGrids(self)

    def addTorsionTorsion(self, *args):
        """
        addTorsionTorsion(self, int particle1, int particle2, int particle3, int particle4, 
            int particle5, int chiralCheckAtomIndex, 
            int gridIndex) -> int

        Add a torsionTorsion term to the force field.
           particle1 -- the index of the first particle connected by the torsionTorsion
           particle2 -- the index of the second particle connected by the torsionTorsion
           particle3 -- the index of the third particle connected by the torsionTorsion
           particle4 -- the index of the fourth particle connected by the torsionTorsion
           particle5 -- the index of the fifth particle connected by the torsionTorsion
           chiralCheckAtomIndex -- the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check
           gridIndex -- the index to the grid to be used
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_addTorsionTorsion(self, *args)

    def getTorsionTorsionParameters(self, *args):
        """
        getTorsionTorsionParameters(self, int index)

        Get the force field parameters for a torsionTorsion term.
           index -- the index of the torsionTorsion for which to get parameters
           particle1 -- the index of the first particle connected by the torsionTorsion
           particle2 -- the index of the second particle connected by the torsionTorsion
           particle3 -- the index of the third particle connected by the torsionTorsion
           particle4 -- the index of the fourth particle connected by the torsionTorsion
           particle5 -- the index of the fifth particle connected by the torsionTorsion
           chiralCheckAtomIndex -- the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check
           gridIndex -- the grid index
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getTorsionTorsionParameters(self, *args)

    def setTorsionTorsionParameters(self, *args):
        """
        setTorsionTorsionParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, int particle5, int chiralCheckAtomIndex, 
            int gridIndex)

        Set the force field parameters for a torsionTorsion term.
           index -- the index of the torsionTorsion for which to set parameters
           particle1 -- the index of the first particle connected by the torsionTorsion
           particle2 -- the index of the second particle connected by the torsionTorsion
           particle3 -- the index of the third particle connected by the torsionTorsion
           particle4 -- the index of the fourth particle connected by the torsionTorsion
           particle5 -- the index of the fifth particle connected by the torsionTorsion
           chiralCheckAtomIndex -- the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check
           gridIndex -- the grid index
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_setTorsionTorsionParameters(self, *args)

    def getTorsionTorsionGrid(self, *args):
        """
        getTorsionTorsionGrid(self, int index) -> vectorddd

        Get the torsion-torsion grid at the specified index
           gridIndex -- the grid index
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getTorsionTorsionGrid(self, *args)

    def setTorsionTorsionGrid(self, *args):
        """
        setTorsionTorsionGrid(self, int index, vectorddd grid)

        Set the torsion-torsion grid at the specified index
           index -- the index of the torsionTorsion for which to get parameters
           grid -- grid grid[x][y][0] = x value grid[x][y][1] = y value grid[x][y][2] = function value grid[x][y][3] = dfdx value grid[x][y][4] = dfdy value grid[x][y][5] = dfd(xy) value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_setTorsionTorsionGrid(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaTorsionTorsionForce
        __init__(self, AmoebaTorsionTorsionForce other) -> AmoebaTorsionTorsionForce

        Create a Amoeba TorsionTorsionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaTorsionTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaTorsionTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaTorsionTorsionForce_swigregister = _openmm.AmoebaTorsionTorsionForce_swigregister
AmoebaTorsionTorsionForce_swigregister(AmoebaTorsionTorsionForce)

class AmoebaUreyBradleyForce(Force):
    """Proxy of C++ OpenMM::AmoebaUreyBradleyForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaUreyBradleyForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaUreyBradleyForce, name)
    __repr__ = _swig_repr
    def getNumInteractions(self):
        """
        getNumInteractions(self) -> int

        Get the number of UB terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_getNumInteractions(self)

    def setAmoebaGlobalUreyBradleyCubic(self, *args):
        """
        setAmoebaGlobalUreyBradleyCubic(self, double cubicK)

        Set the global cubic term
           cubicK -- the cubic force constant
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_setAmoebaGlobalUreyBradleyCubic(self, *args)

    def getAmoebaGlobalUreyBradleyCubic(self):
        """
        getAmoebaGlobalUreyBradleyCubic(self) -> double

        Get the global cubic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_getAmoebaGlobalUreyBradleyCubic(self)

    def setAmoebaGlobalUreyBradleyQuartic(self, *args):
        """
        setAmoebaGlobalUreyBradleyQuartic(self, double quarticK)

        Set the global cubic term
           quarticK -- the quartic force constant
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_setAmoebaGlobalUreyBradleyQuartic(self, *args)

    def getAmoebaGlobalUreyBradleyQuartic(self):
        """
        getAmoebaGlobalUreyBradleyQuartic(self) -> double

        Get the global quartic term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_getAmoebaGlobalUreyBradleyQuartic(self)

    def addUreyBradley(self, *args):
        """
        addUreyBradley(self, int particle1, int particle2, double length, double quadraticK) -> int

        Add a UB term to the force field.
           particle1 -- the index of the first particle
           particle2 -- the index of the second particle
           length -- the equilibrium length, measured in nm
           k -- the quadratic harmonic force constant
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_addUreyBradley(self, *args)

    def getUreyBradleyParameters(self, *args):
        """
        getUreyBradleyParameters(self, int index)

        Get the force field parameters for a bond term.
           index -- the index of the ixn for which to get parameters
           particle1 -- the index of the first particle
           particle2 -- the index of the second particle
           length -- the equilibrium distance, measured in nm
           quadratic -- k the quadratic harmonic force constant
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaUreyBradleyForce_getUreyBradleyParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)
        val[3]=unit.Quantity(val[3], unit.kilojoule_per_mole/(unit.nanometer*unit.nanometer))


        return val

    def setUreyBradleyParameters(self, *args):
        """
        setUreyBradleyParameters(self, int index, int particle1, int particle2, double length, 
            double quadraticK)

        Set the force field parameters for a UB term.
           index -- the index of the ixn for which to set parameters
           particle1 -- the index of the first particle
           particle2 -- the index of the second particle
           length -- the equilibrium distance, measured in nm
           k -- the quadratic harmonic force constant for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaUreyBradleyForce_setUreyBradleyParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaUreyBradleyForce
        __init__(self, AmoebaUreyBradleyForce other) -> AmoebaUreyBradleyForce

        Create a Amoeba UreyBradleyForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaUreyBradleyForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaUreyBradleyForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaUreyBradleyForce_swigregister = _openmm.AmoebaUreyBradleyForce_swigregister
AmoebaUreyBradleyForce_swigregister(AmoebaUreyBradleyForce)

class AmoebaVdwForce(Force):
    """Proxy of C++ OpenMM::AmoebaVdwForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaVdwForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaVdwForce, name)
    __repr__ = _swig_repr
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getNumParticles(self)

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int particleIndex, int ivIndex, int classIndex, double sigma, 
            double epsilon, double reductionFactor)

        Set the force field parameters for a vdw particle.
           particleIndex -- the particle index
           ivIndex -- the iv index
           classIndex -- the class index into the sig-eps table
           sigma -- vdw sigma
           epsilon -- vdw epsilon
           reductionFactor -- the reduction factor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setParticleParameters(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int particleIndex)

        Get the force field parameters for a vdw particle.
           particleIndex -- the particle index
           ivIndex -- the iv index
           classIndex -- the class index into the sig-eps table
           sigma -- vdw sigma
           epsilon -- vdw epsilon
           reductionFactor -- the reduction factor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaVdwForce_getParticleParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)
        val[3]=unit.Quantity(val[3], unit.kilojoule_per_mole)


        return val

    def addParticle(self, *args):
        """
        addParticle(self, int ivIndex, int classIndex, double sigma, double epsilon, 
            double reductionFactor) -> int

        Set the force field parameters for a vdw particle.
           particleIndex -- the particle index
           ivIndex -- the iv index
           classIndex -- the class index into the sig-eps table
           sigma -- vdw sigma
           epsilon -- vdw epsilon
           reductionFactor -- the reduction factor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_addParticle(self, *args)

    def setSigmaCombiningRule(self, *args):
        """
        setSigmaCombiningRule(self, string sigmaCombiningRule)

        Set sigma combining rule
           sigmaCombiningRule -- sigma combining rule: 'ARITHMETIC', 'GEOMETRIC'. 'CUBIC-MEAN'
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setSigmaCombiningRule(self, *args)

    def getSigmaCombiningRule(self):
        """
        getSigmaCombiningRule(self) -> string

        Get sigma combining rule
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getSigmaCombiningRule(self)

    def setEpsilonCombiningRule(self, *args):
        """
        setEpsilonCombiningRule(self, string epsilonCombiningRule)

        Set epsilon combining rule
           epsilonCombiningRule -- epsilon combining rule: 'ARITHMETIC', 'GEOMETRIC'. 'CUBIC-MEAN'
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setEpsilonCombiningRule(self, *args)

    def getEpsilonCombiningRule(self):
        """
        getEpsilonCombiningRule(self) -> string

        Get epsilon combining rule
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getEpsilonCombiningRule(self)

    def setParticleExclusions(self, *args):
        """
        setParticleExclusions(self, int particleIndex, vectori exclusions)

        Set exclusions for specified particle
           particleIndex -- particle index
           exclusions -- output vector of exclusions
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setParticleExclusions(self, *args)

    def getParticleExclusions(self, *args):
        """
        getParticleExclusions(self, int particleIndex)

        Get exclusions for specified particle
           particleIndex -- particle index
           exclusions -- output vector of exclusions
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getParticleExclusions(self, *args)

    def setCutoff(self, *args):
        """
        setCutoff(self, double cutoff)

        Set cutoff
           cutoff -- cutoff
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setCutoff(self, *args)

    def getCutoff(self):
        """
        getCutoff(self) -> double

        Get cutoff
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getCutoff(self)

    def setUseNeighborList(self, *args):
        """
        setUseNeighborList(self, int neighborListFlag)

        Set flag for using neighbor list for vdw ixn
           neighboristFlag -- neighbor list flag
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setUseNeighborList(self, *args)

    def getUseNeighborList(self):
        """
        getUseNeighborList(self) -> int

        Get neighbor list flag for vdw ixn
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getUseNeighborList(self)

    def setPBC(self, *args):
        """
        setPBC(self, int pbcFlag)

        Set flag for employing periodic boundary conditions
           pbcFlag -- if nonozero, use periodic boundary conditions
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setPBC(self, *args)

    def getPBC(self):
        """
        getPBC(self) -> int

        Get periodic boundary conditions flag
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getPBC(self)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaVdwForce
        __init__(self, AmoebaVdwForce other) -> AmoebaVdwForce

        Create a Amoeba VdwForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaVdwForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaVdwForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaVdwForce_swigregister = _openmm.AmoebaVdwForce_swigregister
AmoebaVdwForce_swigregister(AmoebaVdwForce)

class AmoebaWcaDispersionForce(Force):
    """Proxy of C++ OpenMM::AmoebaWcaDispersionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaWcaDispersionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaWcaDispersionForce, name)
    __repr__ = _swig_repr
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getNumParticles(self)

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int particleIndex, double radius, double epsilon)

        Set the force field parameters for a wca dispersion particle.
           particleIndex -- the particle index
           radius -- radius
           epsilon -- epsilon
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setParticleParameters(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int particleIndex)

        Get the force field parameters for a wca dispersion particle.
           particleIndex -- the particle index
           radius -- radius
           epsilon -- epsilon
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.nanometer)
        val[1]=unit.Quantity(val[1], unit.kilojoule_per_mole)


        return val

    def addParticle(self, *args):
        """
        addParticle(self, double radius, double epsilon) -> int

        Set the force field parameters for a wca dispersion particle.
           radius -- radius
           epsilon -- epsilon
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_addParticle(self, *args)

    def getEpso(self):
        """getEpso(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getEpso(self)

    def getEpsh(self):
        """getEpsh(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getEpsh(self)

    def getRmino(self):
        """getRmino(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getRmino(self)

    def getRminh(self):
        """getRminh(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getRminh(self)

    def getAwater(self):
        """getAwater(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getAwater(self)

    def getShctd(self):
        """getShctd(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getShctd(self)

    def getDispoff(self):
        """getDispoff(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getDispoff(self)

    def getSlevy(self):
        """getSlevy(self) -> double"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getSlevy(self)

    def setEpso(self, *args):
        """setEpso(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setEpso(self, *args)

    def setEpsh(self, *args):
        """setEpsh(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setEpsh(self, *args)

    def setRmino(self, *args):
        """setRmino(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setRmino(self, *args)

    def setRminh(self, *args):
        """setRminh(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setRminh(self, *args)

    def setAwater(self, *args):
        """setAwater(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setAwater(self, *args)

    def setShctd(self, *args):
        """setShctd(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setShctd(self, *args)

    def setDispoff(self, *args):
        """setDispoff(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setDispoff(self, *args)

    def setSlevy(self, *args):
        """setSlevy(self, double inputValue)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setSlevy(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AmoebaWcaDispersionForce
        __init__(self, AmoebaWcaDispersionForce other) -> AmoebaWcaDispersionForce

        Create a Amoeba WcaDispersionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaWcaDispersionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaWcaDispersionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaWcaDispersionForce_swigregister = _openmm.AmoebaWcaDispersionForce_swigregister
AmoebaWcaDispersionForce_swigregister(AmoebaWcaDispersionForce)

class AndersenThermostat(Force):
    """Proxy of C++ OpenMM::AndersenThermostat class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AndersenThermostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AndersenThermostat, name)
    __repr__ = _swig_repr
    def Temperature():
        """
        Temperature() -> string

        This is the name of the parameter which stores the current temperature of the heat bath (in Kelvin).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_Temperature()

    if _newclass:Temperature = staticmethod(Temperature)
    __swig_getmethods__["Temperature"] = lambda x: Temperature
    def CollisionFrequency():
        """
        CollisionFrequency() -> string

        This is the name of the parameter which store the current collision frequency (in 1/ps).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_CollisionFrequency()

    if _newclass:CollisionFrequency = staticmethod(CollisionFrequency)
    __swig_getmethods__["CollisionFrequency"] = lambda x: CollisionFrequency
    def getDefaultTemperature(self):
        """
        getDefaultTemperature(self) -> double

        Get the default temperature of the heat bath (in Kelvin).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AndersenThermostat_getDefaultTemperature(self)
        val=unit.Quantity(val, unit.kelvin)


        return val

    def getDefaultCollisionFrequency(self):
        """
        getDefaultCollisionFrequency(self) -> double

        Get the default collision frequency (in 1/ps).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AndersenThermostat_getDefaultCollisionFrequency(self)
        val=unit.Quantity(val, 1/unit.picosecond)


        return val

    def getRandomNumberSeed(self):
        """
        getRandomNumberSeed(self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_getRandomNumberSeed(self)

    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of collisions will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_setRandomNumberSeed(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double defaultTemperature, double defaultCollisionFrequency) -> AndersenThermostat
        __init__(self, AndersenThermostat other) -> AndersenThermostat

        Create an AndersenThermostat.
           defaultTemperature -- the default temperature of the heat bath (in Kelvin)
           defaultCollisionFrequency -- the default collision frequency (in 1/ps)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AndersenThermostat(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_AndersenThermostat
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AndersenThermostat_swigregister = _openmm.AndersenThermostat_swigregister
AndersenThermostat_swigregister(AndersenThermostat)

def AndersenThermostat_Temperature():
  """
    AndersenThermostat_Temperature() -> string

    This is the name of the parameter which stores the current temperature of the heat bath (in Kelvin).
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.AndersenThermostat_Temperature()

def AndersenThermostat_CollisionFrequency():
  """
    AndersenThermostat_CollisionFrequency() -> string

    This is the name of the parameter which store the current collision frequency (in 1/ps).
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.AndersenThermostat_CollisionFrequency()

class Integrator(_object):
    """Proxy of C++ OpenMM::Integrator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Integrator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Integrator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Integrator
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

    def getStepSize(self):
        """
        getStepSize(self) -> double

        Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.Integrator_getStepSize(self)
        val=unit.Quantity(val, unit.picosecond)


        return val

    def setStepSize(self, *args):
        """
        setStepSize(self, double size)

        Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored.
           size -- the step size, measured in ps
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_setStepSize(self, *args)

    def getConstraintTolerance(self):
        """
        getConstraintTolerance(self) -> double

        Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.Integrator_getConstraintTolerance(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setConstraintTolerance(self, *args):
        """
        setConstraintTolerance(self, double tol)

        Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_setConstraintTolerance(self, *args)

    def step(self, *args):
        """
        step(self, int steps)

        Advance a simulation through time by taking a series of time steps.
           steps -- the number of time steps to take
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_step(self, *args)

Integrator_swigregister = _openmm.Integrator_swigregister
Integrator_swigregister(Integrator)

class BrownianIntegrator(Integrator):
    """Proxy of C++ OpenMM::BrownianIntegrator class"""
    __swig_setmethods__ = {}
    for _s in [Integrator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BrownianIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BrownianIntegrator, name)
    __repr__ = _swig_repr
    def getTemperature(self):
        """
        getTemperature(self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.BrownianIntegrator_getTemperature(self)
        val=unit.Quantity(val, unit.kelvin)


        return val

    def setTemperature(self, *args):
        """
        setTemperature(self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           temp -- the temperature of the heat bath, measured in Kelvin.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_setTemperature(self, *args)

    def getFriction(self):
        """
        getFriction(self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.BrownianIntegrator_getFriction(self)
        val=unit.Quantity(val, 1/unit.picosecond)


        return val

    def setFriction(self, *args):
        """
        setFriction(self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           coeff -- the friction coefficient, measured in 1/ps
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_setFriction(self, *args)

    def getRandomNumberSeed(self):
        """
        getRandomNumberSeed(self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_getRandomNumberSeed(self)

    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_setRandomNumberSeed(self, *args)

    def step(self, *args):
        """
        step(self, int steps)

        Advance a simulation through time by taking a series of time steps.
           steps -- the number of time steps to take
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_step(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double temperature, double frictionCoeff, double stepSize) -> BrownianIntegrator
        __init__(self, BrownianIntegrator other) -> BrownianIntegrator

        Create a BrownianIntegrator.
           temperature -- the temperature of the heat bath (in Kelvin)
           frictionCoeff -- the friction coefficient which couples the system to the heat bath, measured in 1/ps
           stepSize -- the step size with which to integrator the system (in picoseconds)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_BrownianIntegrator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_BrownianIntegrator
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

BrownianIntegrator_swigregister = _openmm.BrownianIntegrator_swigregister
BrownianIntegrator_swigregister(BrownianIntegrator)

class CMAPTorsionForce(Force):
    """Proxy of C++ OpenMM::CMAPTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMAPTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CMAPTorsionForce, name)
    __repr__ = _swig_repr
    def getNumMaps(self):
        """
        getNumMaps(self) -> int

        Get the number of maps that have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getNumMaps(self)

    def getNumTorsions(self):
        """
        getNumTorsions(self) -> int

        Get the number of CMAP torsion terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getNumTorsions(self)

    def addMap(self, *args):
        """
        addMap(self, int size, vectord energy) -> int

        Create a new map that can be used for torsion pairs.
           size -- the size of the map along each dimension
           energy -- the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_addMap(self, *args)

    def getMapParameters(self, *args):
        """
        getMapParameters(self, int index)

        Get the energy values of a map.
           index -- the index of the map for which to get energy values
           size -- the size of the map along each dimension
           energy -- the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getMapParameters(self, *args)

    def setMapParameters(self, *args):
        """
        setMapParameters(self, int index, int size, vectord energy)

        Set the energy values of a map.
           index -- the index of the map for which to set energy values
           size -- the size of the map along each dimension
           energy -- the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_setMapParameters(self, *args)

    def addTorsion(self, *args):
        """
        addTorsion(self, int map, int a1, int a2, int a3, int a4, int b1, int b2, 
            int b3, int b4) -> int

        Add a CMAP torsion term to the force field.
           map -- the index of the map to use for this term
           a1 -- the index of the first particle forming the first torsion
           a2 -- the index of the second particle forming the first torsion
           a3 -- the index of the third particle forming the first torsion
           a4 -- the index of the fourth particle forming the first torsion
           b1 -- the index of the first particle forming the second torsion
           b2 -- the index of the second particle forming the second torsion
           b3 -- the index of the third particle forming the second torsion
           b4 -- the index of the fourth particle forming the second torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_addTorsion(self, *args)

    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(self, int index)

        Get the force field parameters for a CMAP torsion term.
           index -- the index of the torsion for which to get parameters
           map -- the index of the map to use for this term
           a1 -- the index of the first particle forming the first torsion
           a2 -- the index of the second particle forming the first torsion
           a3 -- the index of the third particle forming the first torsion
           a4 -- the index of the fourth particle forming the first torsion
           b1 -- the index of the first particle forming the second torsion
           b2 -- the index of the second particle forming the second torsion
           b3 -- the index of the third particle forming the second torsion
           b4 -- the index of the fourth particle forming the second torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getTorsionParameters(self, *args)

    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(self, int index, int map, int a1, int a2, int a3, int a4, 
            int b1, int b2, int b3, int b4)

        Set the force field parameters for a CMAP torsion term.
           index -- the index of the torsion for which to set parameters
           map -- the index of the map to use for this term
           a1 -- the index of the first particle forming the first torsion
           a2 -- the index of the second particle forming the first torsion
           a3 -- the index of the third particle forming the first torsion
           a4 -- the index of the fourth particle forming the first torsion
           b1 -- the index of the first particle forming the second torsion
           b2 -- the index of the second particle forming the second torsion
           b3 -- the index of the third particle forming the second torsion
           b4 -- the index of the fourth particle forming the second torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_setTorsionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CMAPTorsionForce
        __init__(self, CMAPTorsionForce other) -> CMAPTorsionForce

        Create a CMAPTorsionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CMAPTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CMAPTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CMAPTorsionForce_swigregister = _openmm.CMAPTorsionForce_swigregister
CMAPTorsionForce_swigregister(CMAPTorsionForce)

class CMMotionRemover(Force):
    """Proxy of C++ OpenMM::CMMotionRemover class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMMotionRemover, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CMMotionRemover, name)
    __repr__ = _swig_repr
    def getFrequency(self):
        """
        getFrequency(self) -> int

        Get the frequency (in time steps) at which center of mass motion should be removed
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMMotionRemover_getFrequency(self)

    def setFrequency(self, *args):
        """
        setFrequency(self, int freq)

        Set the frequency (in time steps) at which center of mass motion should be removed
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMMotionRemover_setFrequency(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, int frequency = 1) -> CMMotionRemover
        __init__(self) -> CMMotionRemover
        __init__(self, CMMotionRemover other) -> CMMotionRemover

        Create a CMMotionRemover.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CMMotionRemover(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CMMotionRemover
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CMMotionRemover_swigregister = _openmm.CMMotionRemover_swigregister
CMMotionRemover_swigregister(CMMotionRemover)

class Context(_object):
    """Proxy of C++ OpenMM::Context class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Context, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Context, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Context
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

    def getSystem(self, *args):
        """
        getSystem(self) -> System
        getSystem(self) -> System

        Get System being simulated in this context.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getSystem(self, *args)

    def getIntegrator(self, *args):
        """
        getIntegrator(self) -> Integrator
        getIntegrator(self) -> Integrator

        Get Integrator being used to by this context.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getIntegrator(self, *args)

    def getPlatform(self, *args):
        """
        getPlatform(self) -> Platform
        getPlatform(self) -> Platform

        Get the Platform being used for calculations.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getPlatform(self, *args)

    def setTime(self, *args):
        """
        setTime(self, double time)

        Set the current time of the simulation (in picoseconds).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setTime(self, *args)

    def setPositions(self, *args):
        """
        setPositions(self, positions)

        Set the positions of all particles in the System (measured in nm). This method simply sets the positions without checking to see whether they satisfy distance constraints. If you want constraints to be enforced, call applyConstraints() after setting the positions.
           positions -- a vector whose length equals the number of particles in the System. The i'th element contains the position of the i'th particle.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setPositions(self, *args)

    def setVelocities(self, *args):
        """
        setVelocities(self, velocities)

        Set the velocities of all particles in the System (measured in nm/picosecond).
           velocities -- a vector whose length equals the number of particles in the System. The i'th element contains the velocity of the i'th particle.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setVelocities(self, *args)

    def getParameter(self, *args):
        """
        getParameter(self, string name) -> double

        Get the value of an adjustable parameter defined by a Force object in the System.
           name -- the name of the parameter to get
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getParameter(self, *args)

    def setParameter(self, *args):
        """
        setParameter(self, string name, double value)

        Set the value of an adjustable parameter defined by a Force object in the System.
           name -- the name of the parameter to set
           value -- the value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setParameter(self, *args)

    def setPeriodicBoxVectors(self, *args):
        """
        setPeriodicBoxVectors(self, Vec3 a, Vec3 b, Vec3 c)

        Set the vectors defining the axes of the periodic box (measured in nm). They will affect any Force that uses periodic boundary conditions.Currently, only rectangular boxes are supported. This means that a, b, and c must be aligned with the x, y, and z axes respectively. Future releases may support arbitrary triclinic boxes.
           a -- the vector defining the first edge of the periodic box
           b -- the vector defining the second edge of the periodic box
           c -- the vector defining the third edge of the periodic box
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setPeriodicBoxVectors(self, *args)

    def applyConstraints(self, *args):
        """
        applyConstraints(self, double tol)

        Update the positions of particles so that all distance constraints are satisfied.
           tol -- the distance tolerance within which constraints must be satisfied.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_applyConstraints(self, *args)

    def reinitialize(self):
        """
        reinitialize(self)

        When a Context is created, it may cache information about the System being simulated and the Force objects contained in it. This means that, if the System or Forces are then modified, the Context might not see all of the changes. Call reinitialize() to force the Context to rebuild its internal representation of the System and pick up any changes that have been made.This is an expensive operation, so you should try to avoid calling it too frequently.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_reinitialize(self)

    def getStateAsLists(self, getPositions = 0, getVelocities = 0, getForces = 0, 
    getEnergy = 0, getParameters = 0):
        """
        getStateAsLists(self, int getPositions = 0, int getVelocities = 0, int getForces = 0, 
            int getEnergy = 0, int getParameters = 0) -> PyObject
        getStateAsLists(self, int getPositions = 0, int getVelocities = 0, int getForces = 0, 
            int getEnergy = 0) -> PyObject
        getStateAsLists(self, int getPositions = 0, int getVelocities = 0, int getForces = 0) -> PyObject
        getStateAsLists(self, int getPositions = 0, int getVelocities = 0) -> PyObject
        getStateAsLists(self, int getPositions = 0) -> PyObject
        getStateAsLists(self) -> PyObject
        """
        return _openmm.Context_getStateAsLists(self, getPositions, getVelocities, getForces, getEnergy, 
    getParameters)

    def getState(self,
                 getPositions=False,
                 getVelocities=False,
                 getForces=False,
                 getEnergy=False,
                 getParameters=False):
        """
        getState(self,
                 getPositions = False,
                 getVelocities = False,
                 getForces = False,
                 getEnergy=False,
                 getParameters=False)
              -> State
        """
        
        if getPositions: getP=1
        else: getP=0
        if getVelocities: getV=1
        else: getV=0
        if getForces: getF=1
        else: getF=0
        if getEnergy: getE=1
        else: getE=0
        if getParameters: getPa=1
        else: getPa=0

        (simTime, periodicBoxVectorsList, energy, coordList, velList,
         forceList, paramMap) = \
            self.getStateAsLists(getP, getV, getF, getE, getPa)
        
        state = State(simTime=simTime,
                      energy=energy,
                      coordList=coordList,
                      velList=velList,
                      forceList=forceList,
                      periodicBoxVectorsList=periodicBoxVectorsList,
                      paramMap=paramMap)
        return state

    def __init__(self, *args): 
        """
        __init__(self, System system, Integrator integrator) -> Context
        __init__(self, System system, Integrator integrator, Platform platform) -> Context
        __init__(self, System system, Integrator integrator, Platform platform, 
            std::map<(std::string,std::string)> properties) -> Context
        __init__(self, Context other) -> Context

        Construct a new Context in which to run a simulation, explicitly specifying what Platform should be used to perform calculations and the values of platform-specific properties.
           system -- the System which will be simulated
           integrator -- the Integrator which will be used to simulate the System
           platform -- the Platform to use for calculations
           properties -- a set of values for platform-specific properties. Keys are the property names.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Context(*args)
        try: self.this.append(this)
        except: self.this = this
Context_swigregister = _openmm.Context_swigregister
Context_swigregister(Context)

class CustomAngleForce(Force):
    """Proxy of C++ OpenMM::CustomAngleForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomAngleForce, name)
    __repr__ = _swig_repr
    def getNumAngles(self):
        """
        getNumAngles(self) -> int

        Get the number of angles for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getNumAngles(self)

    def getNumPerAngleParameters(self):
        """
        getNumPerAngleParameters(self) -> int

        Get the number of per-angle parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getNumPerAngleParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getNumGlobalParameters(self)

    def getEnergyFunction(self):
        """
        getEnergyFunction(self) -> string

        Get the algebraic expression that gives the interaction energy for each angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getEnergyFunction(self)

    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(self, string energy)

        Set the algebraic expression that gives the interaction energy for each angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setEnergyFunction(self, *args)

    def addPerAngleParameter(self, *args):
        """
        addPerAngleParameter(self, string name) -> int

        Add a new per-angle parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_addPerAngleParameter(self, *args)

    def getPerAngleParameterName(self, *args):
        """
        getPerAngleParameterName(self, int index) -> string

        Get the name of a per-angle parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getPerAngleParameterName(self, *args)

    def setPerAngleParameterName(self, *args):
        """
        setPerAngleParameterName(self, int index, string name)

        Set the name of a per-angle parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setPerAngleParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setGlobalParameterDefaultValue(self, *args)

    def addAngle(self, *args):
        """
        addAngle(self, int particle1, int particle2, int particle3, vectord parameters) -> int

        Add an angle term to the force field.
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           parameters -- the list of parameters for the new angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_addAngle(self, *args)

    def getAngleParameters(self, *args):
        """
        getAngleParameters(self, int index)

        Get the force field parameters for an angle term.
           index -- the index of the angle for which to get parameters
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           parameters -- the list of parameters for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getAngleParameters(self, *args)

    def setAngleParameters(self, *args):
        """
        setAngleParameters(self, int index, int particle1, int particle2, int particle3, 
            vectord parameters)

        Set the force field parameters for an angle term.
           index -- the index of the angle for which to set parameters
           particle1 -- the index of the first particle connected by the angle
           particle2 -- the index of the second particle connected by the angle
           particle3 -- the index of the third particle connected by the angle
           parameters -- the list of parameters for the angle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setAngleParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string energy) -> CustomAngleForce
        __init__(self, CustomAngleForce other) -> CustomAngleForce

        Create a CustomAngleForce.
           energy -- an algebraic expression giving the interaction energy between three particles as a function of theta, the angle between them
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomAngleForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomAngleForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomAngleForce_swigregister = _openmm.CustomAngleForce_swigregister
CustomAngleForce_swigregister(CustomAngleForce)

class CustomBondForce(Force):
    """Proxy of C++ OpenMM::CustomBondForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomBondForce, name)
    __repr__ = _swig_repr
    def getNumBonds(self):
        """
        getNumBonds(self) -> int

        Get the number of bonds for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getNumBonds(self)

    def getNumPerBondParameters(self):
        """
        getNumPerBondParameters(self) -> int

        Get the number of per-bond parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getNumPerBondParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getNumGlobalParameters(self)

    def getEnergyFunction(self):
        """
        getEnergyFunction(self) -> string

        Get the algebraic expression that gives the interaction energy for each bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getEnergyFunction(self)

    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(self, string energy)

        Set the algebraic expression that gives the interaction energy for each bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setEnergyFunction(self, *args)

    def addPerBondParameter(self, *args):
        """
        addPerBondParameter(self, string name) -> int

        Add a new per-bond parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_addPerBondParameter(self, *args)

    def getPerBondParameterName(self, *args):
        """
        getPerBondParameterName(self, int index) -> string

        Get the name of a per-bond parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getPerBondParameterName(self, *args)

    def setPerBondParameterName(self, *args):
        """
        setPerBondParameterName(self, int index, string name)

        Set the name of a per-bond parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setPerBondParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setGlobalParameterDefaultValue(self, *args)

    def addBond(self, *args):
        """
        addBond(self, int particle1, int particle2, vectord parameters) -> int

        Add a bond term to the force field.
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           parameters -- the list of parameters for the new bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_addBond(self, *args)

    def getBondParameters(self, *args):
        """
        getBondParameters(self, int index)

        Get the force field parameters for a bond term.
           index -- the index of the bond for which to get parameters
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           parameters -- the list of parameters for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getBondParameters(self, *args)

    def setBondParameters(self, *args):
        """
        setBondParameters(self, int index, int particle1, int particle2, vectord parameters)

        Set the force field parameters for a bond term.
           index -- the index of the bond for which to set parameters
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           parameters -- the list of parameters for the bond
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setBondParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string energy) -> CustomBondForce
        __init__(self, CustomBondForce other) -> CustomBondForce

        Create a CustomBondForce.
           energy -- an algebraic expression giving the interaction energy between two bonded particles as a function of r, the distance between them
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomBondForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomBondForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomBondForce_swigregister = _openmm.CustomBondForce_swigregister
CustomBondForce_swigregister(CustomBondForce)

class CustomExternalForce(Force):
    """Proxy of C++ OpenMM::CustomExternalForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomExternalForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomExternalForce, name)
    __repr__ = _swig_repr
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getNumParticles(self)

    def getNumPerParticleParameters(self):
        """
        getNumPerParticleParameters(self) -> int

        Get the number of per-particle parameters that the force depends on
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getNumPerParticleParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the force depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getNumGlobalParameters(self)

    def getEnergyFunction(self):
        """
        getEnergyFunction(self) -> string

        Get the algebraic expression that gives the potential energy of each particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getEnergyFunction(self)

    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(self, string energy)

        Set the algebraic expression that gives the potential energy of each particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setEnergyFunction(self, *args)

    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(self, string name) -> int

        Add a new per-particle parameter that the force may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_addPerParticleParameter(self, *args)

    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(self, int index) -> string

        Get the name of a per-particle parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getPerParticleParameterName(self, *args)

    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(self, int index, string name)

        Set the name of a per-particle parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setPerParticleParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the force may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setGlobalParameterDefaultValue(self, *args)

    def addParticle(self, *args):
        """
        addParticle(self, int particle, vectord parameters) -> int

        Add a particle term to the force field.
           particle -- the index of the particle this term is applied to
           parameters -- the list of parameters for the new force term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the force field parameters for a force field term.
           index -- the index of the particle term for which to get parameters
           particle -- the index of the particle this term is applied to
           parameters -- the list of parameters for the force field term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getParticleParameters(self, *args)

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, int particle, vectord parameters)

        Set the force field parameters for a force field term.
           index -- the index of the particle term for which to set parameters
           particle -- the index of the particle this term is applied to
           parameters -- the list of parameters for the force field term
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setParticleParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string energy) -> CustomExternalForce
        __init__(self, CustomExternalForce other) -> CustomExternalForce

        Create a CustomExternalForce.
           energy -- an algebraic expression giving the potential energy of each particle as a function of its x, y, and z coordinates
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomExternalForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomExternalForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomExternalForce_swigregister = _openmm.CustomExternalForce_swigregister
CustomExternalForce_swigregister(CustomExternalForce)

class CustomGBForce(Force):
    """Proxy of C++ OpenMM::CustomGBForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGBForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGBForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomGBForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomGBForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomGBForce_CutoffPeriodic
    SingleParticle = _openmm.CustomGBForce_SingleParticle
    ParticlePair = _openmm.CustomGBForce_ParticlePair
    ParticlePairNoExclusions = _openmm.CustomGBForce_ParticlePairNoExclusions
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumParticles(self)

    def getNumExclusions(self):
        """
        getNumExclusions(self) -> int

        Get the number of particle pairs whose interactions should be excluded.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumExclusions(self)

    def getNumPerParticleParameters(self):
        """
        getNumPerParticleParameters(self) -> int

        Get the number of per-particle parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumPerParticleParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumGlobalParameters(self)

    def getNumFunctions(self):
        """
        getNumFunctions(self) -> int

        Get the number of tabulated functions that have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumFunctions(self)

    def getNumComputedValues(self):
        """
        getNumComputedValues(self) -> int

        Get the number of per-particle computed values the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumComputedValues(self)

    def getNumEnergyTerms(self):
        """
        getNumEnergyTerms(self) -> int

        Get the number of terms in the energy computation.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumEnergyTerms(self)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomGBForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setCutoffDistance(self, *args)

    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(self, string name) -> int

        Add a new per-particle parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addPerParticleParameter(self, *args)

    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(self, int index) -> string

        Get the name of a per-particle parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getPerParticleParameterName(self, *args)

    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(self, int index, string name)

        Set the name of a per-particle parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setPerParticleParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setGlobalParameterDefaultValue(self, *args)

    def addParticle(self, *args):
        """
        addParticle(self, vectord parameters) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           parameters -- the list of parameters for the new particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the nonbonded force parameters for a particle.
           index -- the index of the particle for which to get parameters
           parameters -- the list of parameters for the specified particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getParticleParameters(self, *args)

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, vectord parameters)

        Set the nonbonded force parameters for a particle.
           index -- the index of the particle for which to set parameters
           parameters -- the list of parameters for the specified particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setParticleParameters(self, *args)

    def addComputedValue(self, *args):
        """
        addComputedValue(self, string name, string expression, ComputationType type) -> int

        Add a computed value to calculate for each particle.
           name -- the name of the value
           expression -- an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append "1" to a variable name to indicate the parameter for the particle whose value is being calculated, and "2" to indicate the particle it is interacting with.
           type -- the method to use for computing this value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addComputedValue(self, *args)

    def getComputedValueParameters(self, *args):
        """
        getComputedValueParameters(self, int index)

        Get the properties of a computed value.
           index -- the index of the computed value for which to get parameters
           name -- the name of the value
           expression -- an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append "1" to a variable name to indicate the parameter for the particle whose value is being calculated, and "2" to indicate the particle it is interacting with.
           type -- the method to use for computing this value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getComputedValueParameters(self, *args)

    def setComputedValueParameters(self, *args):
        """
        setComputedValueParameters(self, int index, string name, string expression, ComputationType type)

        Set the properties of a computed value.
           index -- the index of the computed value for which to set parameters
           name -- the name of the value
           expression -- an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append "1" to a variable name to indicate the parameter for the particle whose value is being calculated, and "2" to indicate the particle it is interacting with.
           type -- the method to use for computing this value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setComputedValueParameters(self, *args)

    def addEnergyTerm(self, *args):
        """
        addEnergyTerm(self, string expression, ComputationType type) -> int

        Add a term to the energy computation.
           expression -- an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append "1" to a variable name to indicate the parameter for the first particle in the pair and "2" to indicate the second particle in the pair.
           type -- the method to use for computing this value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addEnergyTerm(self, *args)

    def getEnergyTermParameters(self, *args):
        """
        getEnergyTermParameters(self, int index)

        Get the properties of a term to the energy computation.
           index -- the index of the term for which to get parameters
           expression -- an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append "1" to a variable name to indicate the parameter for the first particle in the pair and "2" to indicate the second particle in the pair.
           type -- the method to use for computing this value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getEnergyTermParameters(self, *args)

    def setEnergyTermParameters(self, *args):
        """
        setEnergyTermParameters(self, int index, string expression, ComputationType type)

        Set the properties of a term to the energy computation.
           index -- the index of the term for which to set parameters
           expression -- an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append "1" to a variable name to indicate the parameter for the first particle in the pair and "2" to indicate the second particle in the pair.
           type -- the method to use for computing this value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setEnergyTermParameters(self, *args)

    def addExclusion(self, *args):
        """
        addExclusion(self, int particle1, int particle2) -> int

        Add a particle pair to the list of interactions that should be excluded.
           particle1 -- the index of the first particle in the pair
           particle2 -- the index of the second particle in the pair
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addExclusion(self, *args)

    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(self, int index)

        Get the particles in a pair whose interaction should be excluded.
           index -- the index of the exclusion for which to get particle indices
           particle1 -- the index of the first particle in the pair
           particle2 -- the index of the second particle in the pair
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getExclusionParticles(self, *args)

    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(self, int index, int particle1, int particle2)

        Set the particles in a pair whose interaction should be excluded.
           index -- the index of the exclusion for which to set particle indices
           particle1 -- the index of the first particle in the pair
           particle2 -- the index of the second particle in the pair
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setExclusionParticles(self, *args)

    def addFunction(self, *args):
        """
        addFunction(self, string name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in the energy expression.
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addFunction(self, *args)

    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(self, int index)

        Get the parameters for a tabulated function that may appear in the energy expression.
           index -- the index of the function for which to get parameters
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getFunctionParameters(self, *args)

    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(self, int index, string name, vectord values, double min, 
            double max)

        Set the parameters for a tabulated function that may appear in algebraic expressions.
           index -- the index of the function for which to set parameters
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setFunctionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CustomGBForce
        __init__(self, CustomGBForce other) -> CustomGBForce

        Create a CustomGBForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomGBForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomGBForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomGBForce_swigregister = _openmm.CustomGBForce_swigregister
CustomGBForce_swigregister(CustomGBForce)

class CustomHbondForce(Force):
    """Proxy of C++ OpenMM::CustomHbondForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomHbondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomHbondForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomHbondForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomHbondForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomHbondForce_CutoffPeriodic
    def getNumDonors(self):
        """
        getNumDonors(self) -> int

        Get the number of donors for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumDonors(self)

    def getNumAcceptors(self):
        """
        getNumAcceptors(self) -> int

        Get the number of acceptors for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumAcceptors(self)

    def getNumExclusions(self):
        """
        getNumExclusions(self) -> int

        Get the number of donor-acceptor pairs whose interactions should be excluded.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumExclusions(self)

    def getNumPerDonorParameters(self):
        """
        getNumPerDonorParameters(self) -> int

        Get the number of per-donor parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumPerDonorParameters(self)

    def getNumPerAcceptorParameters(self):
        """
        getNumPerAcceptorParameters(self) -> int

        Get the number of per-acceptor parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumPerAcceptorParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumGlobalParameters(self)

    def getNumFunctions(self):
        """
        getNumFunctions(self) -> int

        Get the number of tabulated functions that have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumFunctions(self)

    def getEnergyFunction(self):
        """
        getEnergyFunction(self) -> string

        Get the algebraic expression that gives the interaction energy between a donor and an acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getEnergyFunction(self)

    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(self, string energy)

        Set the algebraic expression that gives the interaction energy between a donor and an acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setEnergyFunction(self, *args)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used. All interactions for which the distance between d1 and a1 is greater than the cutoff will be ignored. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomHbondForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used. All interactions for which the distance between d1 and a1 is greater than the cutoff will be ignored. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setCutoffDistance(self, *args)

    def addPerDonorParameter(self, *args):
        """
        addPerDonorParameter(self, string name) -> int

        Add a new per-donor parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addPerDonorParameter(self, *args)

    def getPerDonorParameterName(self, *args):
        """
        getPerDonorParameterName(self, int index) -> string

        Get the name of a per-donor parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getPerDonorParameterName(self, *args)

    def setPerDonorParameterName(self, *args):
        """
        setPerDonorParameterName(self, int index, string name)

        Set the name of a per-donor parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setPerDonorParameterName(self, *args)

    def addPerAcceptorParameter(self, *args):
        """
        addPerAcceptorParameter(self, string name) -> int

        Add a new per-acceptor parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addPerAcceptorParameter(self, *args)

    def getPerAcceptorParameterName(self, *args):
        """
        getPerAcceptorParameterName(self, int index) -> string

        Get the name of a per-acceptor parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getPerAcceptorParameterName(self, *args)

    def setPerAcceptorParameterName(self, *args):
        """
        setPerAcceptorParameterName(self, int index, string name)

        Set the name of a per-acceptor parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setPerAcceptorParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setGlobalParameterDefaultValue(self, *args)

    def addDonor(self, *args):
        """
        addDonor(self, int d1, int d2, int d3, vectord parameters) -> int

        Add a donor group to the force
           d1 -- the index of the first particle for this donor group
           d2 -- the index of the second particle for this donor group. If the group only includes one particle, this must be -1.
           d3 -- the index of the third particle for this donor group. If the group includes less than three particles, this must be -1.
           parameters -- the list of per-donor parameter values for the new donor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addDonor(self, *args)

    def getDonorParameters(self, *args):
        """
        getDonorParameters(self, int index)

        Get the properties of a donor group.
           index -- the index of the donor group to get
           d1 -- the index of the first particle for this donor group
           d2 -- the index of the second particle for this donor group. If the group only includes one particle, this will be -1.
           d3 -- the index of the third particle for this donor group. If the group includes less than three particles, this will be -1.
           parameters -- the list of per-donor parameter values for the new donor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getDonorParameters(self, *args)

    def setDonorParameters(self, *args):
        """
        setDonorParameters(self, int index, int d1, int d2, int d3, vectord parameters)

        Set the properties of a donor group.
           index -- the index of the donor group to set
           d1 -- the index of the first particle for this donor group
           d2 -- the index of the second particle for this donor group. If the group only includes one particle, this must be -1.
           d3 -- the index of the third particle for this donor group. If the group includes less than three particles, this must be -1.
           parameters -- the list of per-donor parameter values for the new donor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setDonorParameters(self, *args)

    def addAcceptor(self, *args):
        """
        addAcceptor(self, int a1, int a2, int a3, vectord parameters) -> int

        Add an acceptor group to the force
           a1 -- the index of the first particle for this acceptor group
           a2 -- the index of the second particle for this acceptor group. If the group only includes one particle, this must be -1.
           a3 -- the index of the third particle for this acceptor group. If the group includes less than three particles, this must be -1.
           parameters -- the list of per-acceptor parameter values for the new acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addAcceptor(self, *args)

    def getAcceptorParameters(self, *args):
        """
        getAcceptorParameters(self, int index)

        Get the properties of an acceptor group.
           index -- the index of the acceptor group to get
           a1 -- the index of the first particle for this acceptor group
           a2 -- the index of the second particle for this acceptor group. If the group only includes one particle, this will be -1.
           a3 -- the index of the third particle for this acceptor group. If the group includes less than three particles, this will be -1.
           parameters -- the list of per-acceptor parameter values for the new acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getAcceptorParameters(self, *args)

    def setAcceptorParameters(self, *args):
        """
        setAcceptorParameters(self, int index, int a1, int a2, int a3, vectord parameters)

        Set the properties of an acceptor group.
           index -- the index of the acceptor group to set
           a1 -- the index of the first particle for this acceptor group
           a2 -- the index of the second particle for this acceptor group. If the group only includes one particle, this must be -1.
           a3 -- the index of the third particle for this acceptor group. If the group includes less than three particles, this must be -1.
           parameters -- the list of per-acceptor parameter values for the new acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setAcceptorParameters(self, *args)

    def addExclusion(self, *args):
        """
        addExclusion(self, int donor, int acceptor) -> int

        Add a donor-acceptor pair to the list of interactions that should be excluded.
           donor -- the index of the donor to exclude
           acceptor -- the index of the acceptor to exclude
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addExclusion(self, *args)

    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(self, int index)

        Get the donor and acceptor in a pair whose interaction should be excluded.
           index -- the index of the exclusion for which to get donor and acceptor indices
           particle1 -- the index of the donor
           particle2 -- the index of the acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getExclusionParticles(self, *args)

    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(self, int index, int donor, int acceptor)

        Get the donor and acceptor in a pair whose interaction should be excluded.
           index -- the index of the exclusion for which to get donor and acceptor indices
           particle1 -- the index of the donor
           particle2 -- the index of the acceptor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setExclusionParticles(self, *args)

    def addFunction(self, *args):
        """
        addFunction(self, string name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in the energy expression.
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addFunction(self, *args)

    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(self, int index)

        Get the parameters for a tabulated function that may appear in the energy expression.
           index -- the index of the function for which to get parameters
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getFunctionParameters(self, *args)

    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(self, int index, string name, vectord values, double min, 
            double max)

        Set the parameters for a tabulated function that may appear in algebraic expressions.
           index -- the index of the function for which to set parameters
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setFunctionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string energy) -> CustomHbondForce
        __init__(self, CustomHbondForce other) -> CustomHbondForce

        Create a CustomHbondForce.
           energy -- an algebraic expression giving the interaction energy between a donor as a function of inter-particle distances, angles, and dihedrals, as well as any global, per-donor, and per-acceptor parameters
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomHbondForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomHbondForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomHbondForce_swigregister = _openmm.CustomHbondForce_swigregister
CustomHbondForce_swigregister(CustomHbondForce)

class CustomNonbondedForce(Force):
    """Proxy of C++ OpenMM::CustomNonbondedForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomNonbondedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomNonbondedForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomNonbondedForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomNonbondedForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomNonbondedForce_CutoffPeriodic
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumParticles(self)

    def getNumExclusions(self):
        """
        getNumExclusions(self) -> int

        Get the number of particle pairs whose interactions should be excluded.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumExclusions(self)

    def getNumPerParticleParameters(self):
        """
        getNumPerParticleParameters(self) -> int

        Get the number of per-particle parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumPerParticleParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumGlobalParameters(self)

    def getNumFunctions(self):
        """
        getNumFunctions(self) -> int

        Get the number of tabulated functions that have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumFunctions(self)

    def getEnergyFunction(self):
        """
        getEnergyFunction(self) -> string

        Get the algebraic expression that gives the interaction energy between two particles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getEnergyFunction(self)

    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(self, string energy)

        Set the algebraic expression that gives the interaction energy between two particles
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setEnergyFunction(self, *args)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomNonbondedForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setCutoffDistance(self, *args)

    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(self, string name) -> int

        Add a new per-particle parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addPerParticleParameter(self, *args)

    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(self, int index) -> string

        Get the name of a per-particle parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getPerParticleParameterName(self, *args)

    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(self, int index, string name)

        Set the name of a per-particle parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setPerParticleParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setGlobalParameterDefaultValue(self, *args)

    def addParticle(self, *args):
        """
        addParticle(self, vectord parameters) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           parameters -- the list of parameters for the new particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the nonbonded force parameters for a particle.
           index -- the index of the particle for which to get parameters
           parameters -- the list of parameters for the specified particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getParticleParameters(self, *args)

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, vectord parameters)

        Set the nonbonded force parameters for a particle.
           index -- the index of the particle for which to set parameters
           parameters -- the list of parameters for the specified particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setParticleParameters(self, *args)

    def addExclusion(self, *args):
        """
        addExclusion(self, int particle1, int particle2) -> int

        Add a particle pair to the list of interactions that should be excluded.
           particle1 -- the index of the first particle in the pair
           particle2 -- the index of the second particle in the pair
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addExclusion(self, *args)

    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(self, int index)

        Get the particles in a pair whose interaction should be excluded.
           index -- the index of the exclusion for which to get particle indices
           particle1 -- the index of the first particle in the pair
           particle2 -- the index of the second particle in the pair
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getExclusionParticles(self, *args)

    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(self, int index, int particle1, int particle2)

        Set the particles in a pair whose interaction should be excluded.
           index -- the index of the exclusion for which to set particle indices
           particle1 -- the index of the first particle in the pair
           particle2 -- the index of the second particle in the pair
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setExclusionParticles(self, *args)

    def addFunction(self, *args):
        """
        addFunction(self, string name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in the energy expression.
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addFunction(self, *args)

    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(self, int index)

        Get the parameters for a tabulated function that may appear in the energy expression.
           index -- the index of the function for which to get parameters
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getFunctionParameters(self, *args)

    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(self, int index, string name, vectord values, double min, 
            double max)

        Set the parameters for a tabulated function that may appear in algebraic expressions.
           index -- the index of the function for which to set parameters
           name -- the name of the function as it appears in expressions
           values -- the tabulated values of the function f(x) at uniformly spaced values of x between min and max. The function is assumed to be zero for x < min or x > max.
           min -- the value of the independent variable corresponding to the first element of values
           max -- the value of the independent variable corresponding to the last element of values
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setFunctionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string energy) -> CustomNonbondedForce
        __init__(self, CustomNonbondedForce other) -> CustomNonbondedForce

        Create a CustomNonbondedForce.
           energy -- an algebraic expression giving the interaction energy between two particles as a function of r, the distance between them, as well as any global and per-particle parameters
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomNonbondedForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomNonbondedForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomNonbondedForce_swigregister = _openmm.CustomNonbondedForce_swigregister
CustomNonbondedForce_swigregister(CustomNonbondedForce)

class CustomTorsionForce(Force):
    """Proxy of C++ OpenMM::CustomTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomTorsionForce, name)
    __repr__ = _swig_repr
    def getNumTorsions(self):
        """
        getNumTorsions(self) -> int

        Get the number of torsions for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getNumTorsions(self)

    def getNumPerTorsionParameters(self):
        """
        getNumPerTorsionParameters(self) -> int

        Get the number of per-torsion parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getNumPerTorsionParameters(self)

    def getNumGlobalParameters(self):
        """
        getNumGlobalParameters(self) -> int

        Get the number of global parameters that the interaction depends on.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getNumGlobalParameters(self)

    def getEnergyFunction(self):
        """
        getEnergyFunction(self) -> string

        Get the algebraic expression that gives the interaction energy for each torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getEnergyFunction(self)

    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(self, string energy)

        Set the algebraic expression that gives the interaction energy for each torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setEnergyFunction(self, *args)

    def addPerTorsionParameter(self, *args):
        """
        addPerTorsionParameter(self, string name) -> int

        Add a new per-torsion parameter that the interaction may depend on.
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_addPerTorsionParameter(self, *args)

    def getPerTorsionParameterName(self, *args):
        """
        getPerTorsionParameterName(self, int index) -> string

        Get the name of a per-torsion parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getPerTorsionParameterName(self, *args)

    def setPerTorsionParameterName(self, *args):
        """
        setPerTorsionParameterName(self, int index, string name)

        Set the name of a per-torsion parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setPerTorsionParameterName(self, *args)

    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(self, string name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           name -- the name of the parameter
           defaultValue -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_addGlobalParameter(self, *args)

    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(self, int index) -> string

        Get the name of a global parameter.
           index -- the index of the parameter for which to get the name
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getGlobalParameterName(self, *args)

    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(self, int index, string name)

        Set the name of a global parameter.
           index -- the index of the parameter for which to set the name
           name -- the name of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setGlobalParameterName(self, *args)

    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(self, int index) -> double

        Get the default value of a global parameter.
           index -- the index of the parameter for which to get the default value
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getGlobalParameterDefaultValue(self, *args)

    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(self, int index, double defaultValue)

        Set the default value of a global parameter.
           index -- the index of the parameter for which to set the default value
           name -- the default value of the parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setGlobalParameterDefaultValue(self, *args)

    def addTorsion(self, *args):
        """
        addTorsion(self, int particle1, int particle2, int particle3, int particle4, 
            vectord parameters) -> int

        Add a torsion term to the force field.
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           parameters -- the list of parameters for the new torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_addTorsion(self, *args)

    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(self, int index)

        Get the force field parameters for a torsion term.
           index -- the index of the torsion for which to get parameters
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           parameters -- the list of parameters for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getTorsionParameters(self, *args)

    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, vectord parameters)

        Set the force field parameters for a torsion term.
           index -- the index of the torsion for which to set parameters
           particle1 -- the index of the first particle connected by the torsion
           particle2 -- the index of the second particle connected by the torsion
           particle3 -- the index of the third particle connected by the torsion
           particle4 -- the index of the fourth particle connected by the torsion
           parameters -- the list of parameters for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setTorsionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, string energy) -> CustomTorsionForce
        __init__(self, CustomTorsionForce other) -> CustomTorsionForce

        Create a CustomTorsionForce.
           energy -- an algebraic expression giving the interaction energy between three particles as a function of theta, the torsion angle between them
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_CustomTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomTorsionForce_swigregister = _openmm.CustomTorsionForce_swigregister
CustomTorsionForce_swigregister(CustomTorsionForce)

class GBSAOBCForce(Force):
    """Proxy of C++ OpenMM::GBSAOBCForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GBSAOBCForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GBSAOBCForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.GBSAOBCForce_NoCutoff
    CutoffNonPeriodic = _openmm.GBSAOBCForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.GBSAOBCForce_CutoffPeriodic
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles in the system.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_getNumParticles(self)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double radius, double scalingFactor) -> int

        Add the GBSA parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the force field parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.dimensionless)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double radius, double scalingFactor)

        Set the force field parameters for a particle.
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setParticleParameters(self, *args)

    def getSolventDielectric(self):
        """
        getSolventDielectric(self) -> double

        Get the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getSolventDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(self, double dielectric)

        Set the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setSolventDielectric(self, *args)

    def getSoluteDielectric(self):
        """
        getSoluteDielectric(self) -> double

        Get the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getSoluteDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(self, double dielectric)

        Set the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setSoluteDielectric(self, *args)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setCutoffDistance(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> GBSAOBCForce
        __init__(self, GBSAOBCForce other) -> GBSAOBCForce
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_GBSAOBCForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_GBSAOBCForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

GBSAOBCForce_swigregister = _openmm.GBSAOBCForce_swigregister
GBSAOBCForce_swigregister(GBSAOBCForce)

class GBSAOBCSoftcoreForce(Force):
    """Proxy of C++ OpenMM::GBSAOBCSoftcoreForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GBSAOBCSoftcoreForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GBSAOBCSoftcoreForce, name)
    __repr__ = _swig_repr
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles in the system.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCSoftcoreForce_getNumParticles(self)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double radius, double scalingFactor, 
            double nonPolarScalingFactor = 1.0) -> int
        addParticle(self, double charge, double radius, double scalingFactor) -> int

        Add the GBSA parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
           nonPolarScalingFactor -- the nonpolar scaling factor for the particle (default: 1.0)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCSoftcoreForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the force field parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
           nonPolarScalingFactor -- the nonpolar scaling factor for the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCSoftcoreForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.dimensionless)
        val[3]=unit.Quantity(val[3], unit.dimensionless)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double radius, double scalingFactor, 
            double nonPolarScalingFactor = 1.0)
        setParticleParameters(self, int index, double charge, double radius, double scalingFactor)

        Set the force field parameters for a particle.
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           scalingFactor -- the OBC scaling factor for the particle
           nonPolarScalingFactor -- the nonpolar scaling factor for the particle (default: 1.0)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCSoftcoreForce_setParticleParameters(self, *args)

    def getSolventDielectric(self):
        """
        getSolventDielectric(self) -> double

        Get the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCSoftcoreForce_getSolventDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(self, double dielectric)

        Set the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCSoftcoreForce_setSolventDielectric(self, *args)

    def getSoluteDielectric(self):
        """
        getSoluteDielectric(self) -> double

        Get the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCSoftcoreForce_getSoluteDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(self, double dielectric)

        Set the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCSoftcoreForce_setSoluteDielectric(self, *args)

    def getNonPolarPrefactor(self):
        """
        getNonPolarPrefactor(self) -> double

        Get the nonPolarPrefactor.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCSoftcoreForce_getNonPolarPrefactor(self)
        val=unit.Quantity(val, unit.kilojoule_per_mole/(unit.nanometer*unit.nanometer))


        return val

    def setNonPolarPrefactor(self, *args):
        """
        setNonPolarPrefactor(self, double inputNonPolarPrefactor)

        Set the nonPolarPrefactor; units are kJ/mol/nm^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCSoftcoreForce_setNonPolarPrefactor(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> GBSAOBCSoftcoreForce
        __init__(self, GBSAOBCSoftcoreForce other) -> GBSAOBCSoftcoreForce
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_GBSAOBCSoftcoreForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_GBSAOBCSoftcoreForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

GBSAOBCSoftcoreForce_swigregister = _openmm.GBSAOBCSoftcoreForce_swigregister
GBSAOBCSoftcoreForce_swigregister(GBSAOBCSoftcoreForce)

class GBVIForce(Force):
    """Proxy of C++ OpenMM::GBVIForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GBVIForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GBVIForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.GBVIForce_NoCutoff
    CutoffNonPeriodic = _openmm.GBVIForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.GBVIForce_CutoffPeriodic
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles in the system.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getNumParticles(self)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double radius, double gamma) -> int

        Add the GB/VI parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GB/VI radius of the particle, measured in nm
           gamma -- the gamma parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the force field parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           gamma -- the gamma parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double radius, double gamma)

        Set the force field parameters for a particle.
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GB/VI radius of the particle, measured in nm
           gamma -- the gamma parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setParticleParameters(self, *args)

    def addBond(self, *args):
        """
        addBond(self, int particle1, int particle2, double distance) -> int

        Add a bond
           particle1 -- the index of the first particle
           particle2 -- the index of the second particle
           distance -- the distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_addBond(self, *args)

    def getBondParameters(self, *args):
        """
        getBondParameters(self, int index)

        Get the parameters defining a bond
           index -- the index of the bond for which to get parameters
           particle1 -- the index of the first particle involved in the bond
           particle2 -- the index of the second particle involved in the bond
           distance -- the distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getBondParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val

    def setBondParameters(self, *args):
        """
        setBondParameters(self, int index, int particle1, int particle2, double bondLength)

        Set 1-2 bonds
           index -- index of the bond for which to set parameters
           particle1 -- index of first atom in bond
           particle2 -- index of second atom in bond
           bondLength -- bond length
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setBondParameters(self, *args)

    def getNumBonds(self):
        """
        getNumBonds(self) -> int

        Get number of bonds
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getNumBonds(self)

    def getSolventDielectric(self):
        """
        getSolventDielectric(self) -> double

        Get the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getSolventDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(self, double dielectric)

        Set the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setSolventDielectric(self, *args)

    def getSoluteDielectric(self):
        """
        getSoluteDielectric(self) -> double

        Get the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getSoluteDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(self, double dielectric)

        Set the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setSoluteDielectric(self, *args)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setCutoffDistance(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> GBVIForce
        __init__(self, GBVIForce other) -> GBVIForce
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_GBVIForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_GBVIForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

GBVIForce_swigregister = _openmm.GBVIForce_swigregister
GBVIForce_swigregister(GBVIForce)

class GBVISoftcoreForce(Force):
    """Proxy of C++ OpenMM::GBVISoftcoreForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GBVISoftcoreForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GBVISoftcoreForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.GBVISoftcoreForce_NoCutoff
    CutoffNonPeriodic = _openmm.GBVISoftcoreForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.GBVISoftcoreForce_CutoffPeriodic
    NoScaling = _openmm.GBVISoftcoreForce_NoScaling
    Tanh = _openmm.GBVISoftcoreForce_Tanh
    QuinticSpline = _openmm.GBVISoftcoreForce_QuinticSpline
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles in the system.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getNumParticles(self)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double radius, double gamma, double bornRadiusScaleFactor = 1.0)
        addParticle(self, double charge, double radius, double gamma)

        Add the GB/VI parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GB/VI radius of the particle, measured in nm
           gamma -- the gamma parameter
           bornRadiusScaleFactor -- the Born radius scale factor (used for free energy calculations)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the force field parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GBSA radius of the particle, measured in nm
           gamma -- the gamma parameter
           bornRadiusScaleFactor -- the Born radius scale factor (used for free energy calculations)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVISoftcoreForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)
        val[3]=unit.Quantity(val[3], unit.dimensionless)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double radius, double gamma, 
            double bornRadiusScaleFactor = 1.0)
        setParticleParameters(self, int index, double charge, double radius, double gamma)

        Set the force field parameters for a particle.
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           radius -- the GB/VI radius of the particle, measured in nm
           gamma -- the gamma parameter
           bornRadiusScaleFactor -- the Born radius scale factor (used for free energy calculations)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setParticleParameters(self, *args)

    def addBond(self, *args):
        """
        addBond(self, int particle1, int particle2, double distance) -> int

        Add a bond
           particle1 -- the index of the first particle
           particle2 -- the index of the second particle
           distance -- the distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_addBond(self, *args)

    def getBondParameters(self, *args):
        """
        getBondParameters(self, int index)

        Get the parameters defining a bond
           index -- the index of the bond for which to get parameters
           particle1 -- the index of the first particle involved in the bond
           particle2 -- the index of the second particle involved in the bond
           distance -- the distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVISoftcoreForce_getBondParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val

    def setBondParameters(self, *args):
        """
        setBondParameters(self, int index, int particle1, int particle2, double bondLength)

        Set 1-2 bonds
           index -- index of the bond for which to set parameters
           particle1 -- index of first atom in bond
           particle2 -- index of second atom in bond
           bondLength -- bond length
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setBondParameters(self, *args)

    def getNumBonds(self):
        """
        getNumBonds(self) -> int

        Get number of bonds
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getNumBonds(self)

    def getSolventDielectric(self):
        """
        getSolventDielectric(self) -> double

        Get the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVISoftcoreForce_getSolventDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(self, double dielectric)

        Set the dielectric constant for the solvent.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setSolventDielectric(self, *args)

    def getSoluteDielectric(self):
        """
        getSoluteDielectric(self) -> double

        Get the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVISoftcoreForce_getSoluteDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(self, double dielectric)

        Set the dielectric constant for the solute.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setSoluteDielectric(self, *args)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedSoftcoreMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedSoftcoreMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVISoftcoreForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setCutoffDistance(self, *args)

    def getBornRadiusScalingMethod(self):
        """
        getBornRadiusScalingMethod(self) -> BornRadiusScalingSoftcoreMethod

        Get the method used for scaling Born radii.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getBornRadiusScalingMethod(self)

    def setBornRadiusScalingMethod(self, *args):
        """
        setBornRadiusScalingMethod(self, BornRadiusScalingSoftcoreMethod method)

        Set the method used for scaling Born radii.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setBornRadiusScalingMethod(self, *args)

    def getQuinticLowerLimitFactor(self):
        """
        getQuinticLowerLimitFactor(self) -> double

        Get the lower limit factor used in the quintic spline scaling method (typically 0.5-0.8)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getQuinticLowerLimitFactor(self)

    def setQuinticLowerLimitFactor(self, *args):
        """
        setQuinticLowerLimitFactor(self, double quinticLowerLimitFactor)

        Set the lower limit factor used in the quintic spline scaling method (typically 0.5-0.8)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setQuinticLowerLimitFactor(self, *args)

    def getQuinticUpperBornRadiusLimit(self):
        """
        getQuinticUpperBornRadiusLimit(self) -> double

        Get the upper limit used in the quintic spline scaling method (typically 0.5-0.8)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getQuinticUpperBornRadiusLimit(self)

    def setQuinticUpperBornRadiusLimit(self, *args):
        """
        setQuinticUpperBornRadiusLimit(self, double quinticUpperBornRadiusLimit)

        Set the upper limit used in the quintic spline scaling method (typically 0.008)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setQuinticUpperBornRadiusLimit(self, *args)

    def getTanhParameters(self):
        """
        getTanhParameters(self)

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_getTanhParameters(self)

    def setTanhParameters(self, *args):
        """
        setTanhParameters(self, double alpha, double beta, double gamma)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVISoftcoreForce_setTanhParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> GBVISoftcoreForce
        __init__(self, GBVISoftcoreForce other) -> GBVISoftcoreForce
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_GBVISoftcoreForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_GBVISoftcoreForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

GBVISoftcoreForce_swigregister = _openmm.GBVISoftcoreForce_swigregister
GBVISoftcoreForce_swigregister(GBVISoftcoreForce)

class HarmonicAngleForce(Force):
    """Proxy of C++ OpenMM::HarmonicAngleForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HarmonicAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HarmonicAngleForce, name)
    __repr__ = _swig_repr
    def getNumAngles(self):
        """
        getNumAngles(self) -> int

        Get the number of harmonic bond angle terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_getNumAngles(self)

    def addAngle(self, *args):
        """
        addAngle(self, int particle1, int particle2, int particle3, double angle, 
            double k) -> int

        Add an angle term to the force field.
           particle1 -- the index of the first particle forming the angle
           particle2 -- the index of the second particle forming the angle
           particle3 -- the index of the third particle forming the angle
           angle -- the equilibrium angle, measured in radians
           k -- the harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_addAngle(self, *args)

    def getAngleParameters(self, *args):
        """
        getAngleParameters(self, int index)

        Get the force field parameters for an angle term.
           index -- the index of the angle for which to get parameters
           particle1 -- the index of the first particle forming the angle
           particle2 -- the index of the second particle forming the angle
           particle3 -- the index of the third particle forming the angle
           angle -- the equilibrium angle, measured in radians
           k -- the harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.HarmonicAngleForce_getAngleParameters(self, *args)
        val[3]=unit.Quantity(val[3], unit.radian)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole/(unit.radian*unit.radian))


        return val

    def setAngleParameters(self, *args):
        """
        setAngleParameters(self, int index, int particle1, int particle2, int particle3, 
            double angle, double k)

        Set the force field parameters for an angle term.
           index -- the index of the angle for which to set parameters
           particle1 -- the index of the first particle forming the angle
           particle2 -- the index of the second particle forming the angle
           particle3 -- the index of the third particle forming the angle
           angle -- the equilibrium angle, measured in radians
           k -- the harmonic force constant for the angle, measured in kJ/mol/radian^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_setAngleParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> HarmonicAngleForce
        __init__(self, HarmonicAngleForce other) -> HarmonicAngleForce

        Create a HarmonicAngleForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_HarmonicAngleForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_HarmonicAngleForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

HarmonicAngleForce_swigregister = _openmm.HarmonicAngleForce_swigregister
HarmonicAngleForce_swigregister(HarmonicAngleForce)

class HarmonicBondForce(Force):
    """Proxy of C++ OpenMM::HarmonicBondForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HarmonicBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HarmonicBondForce, name)
    __repr__ = _swig_repr
    def getNumBonds(self):
        """
        getNumBonds(self) -> int

        Get the number of harmonic bond stretch terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_getNumBonds(self)

    def addBond(self, *args):
        """
        addBond(self, int particle1, int particle2, double length, double k) -> int

        Add a bond term to the force field.
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           length -- the equilibrium length of the bond, measured in nm
           k -- the harmonic force constant for the bond, measured in kJ/mol/nm^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_addBond(self, *args)

    def getBondParameters(self, *args):
        """
        getBondParameters(self, int index)

        Get the force field parameters for a bond term.
           index -- the index of the bond for which to get parameters
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           length -- the equilibrium length of the bond, measured in nm
           k -- the harmonic force constant for the bond, measured in kJ/mol/nm^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.HarmonicBondForce_getBondParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)
        val[3]=unit.Quantity(val[3], unit.kilojoule_per_mole/(unit.nanometer*unit.nanometer))


        return val

    def setBondParameters(self, *args):
        """
        setBondParameters(self, int index, int particle1, int particle2, double length, 
            double k)

        Set the force field parameters for a bond term.
           index -- the index of the bond for which to set parameters
           particle1 -- the index of the first particle connected by the bond
           particle2 -- the index of the second particle connected by the bond
           length -- the equilibrium length of the bond, measured in nm
           k -- the harmonic force constant for the bond, measured in kJ/mol/nm^2
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_setBondParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> HarmonicBondForce
        __init__(self, HarmonicBondForce other) -> HarmonicBondForce

        Create a HarmonicBondForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_HarmonicBondForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_HarmonicBondForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

HarmonicBondForce_swigregister = _openmm.HarmonicBondForce_swigregister
HarmonicBondForce_swigregister(HarmonicBondForce)

class LangevinIntegrator(Integrator):
    """Proxy of C++ OpenMM::LangevinIntegrator class"""
    __swig_setmethods__ = {}
    for _s in [Integrator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LangevinIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LangevinIntegrator, name)
    __repr__ = _swig_repr
    def getTemperature(self):
        """
        getTemperature(self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.LangevinIntegrator_getTemperature(self)
        val=unit.Quantity(val, unit.kelvin)


        return val

    def setTemperature(self, *args):
        """
        setTemperature(self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           temp -- the temperature of the heat bath, measured in Kelvin
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_setTemperature(self, *args)

    def getFriction(self):
        """
        getFriction(self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.LangevinIntegrator_getFriction(self)
        val=unit.Quantity(val, 1/unit.picosecond)


        return val

    def setFriction(self, *args):
        """
        setFriction(self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           coeff -- the friction coefficient, measured in 1/ps
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_setFriction(self, *args)

    def getRandomNumberSeed(self):
        """
        getRandomNumberSeed(self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_getRandomNumberSeed(self)

    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_setRandomNumberSeed(self, *args)

    def step(self, *args):
        """
        step(self, int steps)

        Advance a simulation through time by taking a series of time steps.
           steps -- the number of time steps to take
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_step(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double temperature, double frictionCoeff, double stepSize) -> LangevinIntegrator
        __init__(self, LangevinIntegrator other) -> LangevinIntegrator

        Create a LangevinIntegrator.
           temperature -- the temperature of the heat bath (in Kelvin)
           frictionCoeff -- the friction coefficient which couples the system to the heat bath (in inverse picoseconds)
           stepSize -- the step size with which to integrator the system (in picoseconds)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_LangevinIntegrator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_LangevinIntegrator
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

LangevinIntegrator_swigregister = _openmm.LangevinIntegrator_swigregister
LangevinIntegrator_swigregister(LangevinIntegrator)

class LocalEnergyMinimizer(_object):
    """Proxy of C++ OpenMM::LocalEnergyMinimizer class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalEnergyMinimizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalEnergyMinimizer, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def minimize(*args):
        """
        minimize(Context context, double tolerance = 1, int maxIterations = 0)
        minimize(Context context, double tolerance = 1)
        minimize(Context context)

        Search for a new set of particle positions that represent a local potential energy minimum. On exit, the Context will have been updated with the new positions.
           context -- a Context specifying the System to minimize and the initial particle positions
           tolerance -- this specifies how precisely the energy minimum must be located. Minimization will be halted once the root-mean-square value of all force components reaches this tolerance. The default value is 1.
           maxIterations -- the maximum number of iterations to perform. If this is 0, minimation is continued until the results converge without regard to how many iterations it takes. The default value is 0.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LocalEnergyMinimizer_minimize(*args)

    if _newclass:minimize = staticmethod(minimize)
    __swig_getmethods__["minimize"] = lambda x: minimize
    __swig_destroy__ = _openmm.delete_LocalEnergyMinimizer
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

LocalEnergyMinimizer_swigregister = _openmm.LocalEnergyMinimizer_swigregister
LocalEnergyMinimizer_swigregister(LocalEnergyMinimizer)

def LocalEnergyMinimizer_minimize(*args):
  """
    minimize(Context context, double tolerance = 1, int maxIterations = 0)
    minimize(Context context, double tolerance = 1)
    LocalEnergyMinimizer_minimize(Context context)

    Search for a new set of particle positions that represent a local potential energy minimum. On exit, the Context will have been updated with the new positions.
       context -- a Context specifying the System to minimize and the initial particle positions
       tolerance -- this specifies how precisely the energy minimum must be located. Minimization will be halted once the root-mean-square value of all force components reaches this tolerance. The default value is 1.
       maxIterations -- the maximum number of iterations to perform. If this is 0, minimation is continued until the results converge without regard to how many iterations it takes. The default value is 0.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.LocalEnergyMinimizer_minimize(*args)

class MonteCarloBarostat(Force):
    """Proxy of C++ OpenMM::MonteCarloBarostat class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MonteCarloBarostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MonteCarloBarostat, name)
    __repr__ = _swig_repr
    def Pressure():
        """
        Pressure() -> string

        This is the name of the parameter which stores the current pressure acting on the system (in bar).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_Pressure()

    if _newclass:Pressure = staticmethod(Pressure)
    __swig_getmethods__["Pressure"] = lambda x: Pressure
    def getDefaultPressure(self):
        """
        getDefaultPressure(self) -> double

        Get the default pressure acting on the system (in bar).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloBarostat_getDefaultPressure(self)
        val=unit.Quantity(val, unit.bar)


        return val

    def getFrequency(self):
        """
        getFrequency(self) -> int

        Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_getFrequency(self)

    def setFrequency(self, *args):
        """
        setFrequency(self, int freq)

        Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setFrequency(self, *args)

    def getTemperature(self):
        """
        getTemperature(self) -> double

        Get the temperature at which the system is being maintained, measured in Kelvin.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloBarostat_getTemperature(self)
        val=unit.Quantity(val, unit.kelvin)


        return val

    def setTemperature(self, *args):
        """
        setTemperature(self, double temp)

        Set the temperature at which the system is being maintained.
           temp -- the system temperature, measured in Kelvin.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setTemperature(self, *args)

    def getRandomNumberSeed(self):
        """
        getRandomNumberSeed(self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_getRandomNumberSeed(self)

    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(self, int seed)

        Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setRandomNumberSeed(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double defaultPressure, double temperature, int frequency = 25) -> MonteCarloBarostat
        __init__(self, double defaultPressure, double temperature) -> MonteCarloBarostat
        __init__(self, MonteCarloBarostat other) -> MonteCarloBarostat

        Create a MonteCarloBarostat.
           defaultPressure -- the default pressure acting on the system (in bar)
           temperature -- the temperature at which the system is being maintained (in Kelvin)
           frequency -- the frequency at which Monte Carlo pressure changes should be attempted (in time steps)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_MonteCarloBarostat(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_MonteCarloBarostat
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

MonteCarloBarostat_swigregister = _openmm.MonteCarloBarostat_swigregister
MonteCarloBarostat_swigregister(MonteCarloBarostat)

def MonteCarloBarostat_Pressure():
  """
    MonteCarloBarostat_Pressure() -> string

    This is the name of the parameter which stores the current pressure acting on the system (in bar).
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.MonteCarloBarostat_Pressure()

class NonbondedForce(Force):
    """Proxy of C++ OpenMM::NonbondedForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NonbondedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NonbondedForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.NonbondedForce_NoCutoff
    CutoffNonPeriodic = _openmm.NonbondedForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.NonbondedForce_CutoffPeriodic
    Ewald = _openmm.NonbondedForce_Ewald
    PME = _openmm.NonbondedForce_PME
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getNumParticles(self)

    def getNumExceptions(self):
        """
        getNumExceptions(self) -> int

        Get the number of special interactions that should be calculated differently from other interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getNumExceptions(self)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           distance -- the cutoff distance, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setCutoffDistance(self, *args)

    def getReactionFieldDielectric(self):
        """
        getReactionFieldDielectric(self) -> double

        Get the dielectric constant to use for the solvent in the reaction field approximation.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getReactionFieldDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setReactionFieldDielectric(self, *args):
        """
        setReactionFieldDielectric(self, double dielectric)

        Set the dielectric constant to use for the solvent in the reaction field approximation.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setReactionFieldDielectric(self, *args)

    def getEwaldErrorTolerance(self):
        """
        getEwaldErrorTolerance(self) -> double

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getEwaldErrorTolerance(self)

    def setEwaldErrorTolerance(self, *args):
        """
        setEwaldErrorTolerance(self, double tol)

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setEwaldErrorTolerance(self, *args)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double sigma, double epsilon) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle. For calculating the Lennard-Jones interaction between two particles, the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles is used (the Lorentz-Bertelot combining rule).
           charge -- the charge of the particle, measured in units of the proton charge
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the nonbonded force parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double sigma, double epsilon)

        Set the nonbonded force parameters for a particle. When calculating the Lennard-Jones interaction between two particles, it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles (the Lorentz-Bertelot combining rule).
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setParticleParameters(self, *args)

    def addException(self, *args):
        """
        addException(self, int particle1, int particle2, double chargeProd, double sigma, 
            double epsilon, bool replace = False) -> int
        addException(self, int particle1, int particle2, double chargeProd, double sigma, 
            double epsilon) -> int

        Add an interaction to the list of exceptions that should be calculated differently from other interactions. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations.In many cases, you can use createExceptionsFromBonds() rather than adding each exception explicitly.
           particle1 -- the index of the first particle involved in the interaction
           particle2 -- the index of the second particle involved in the interaction
           chargeProd -- the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           replace -- determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_addException(self, *args)

    def getExceptionParameters(self, *args):
        """
        getExceptionParameters(self, int index)

        Get the force field parameters for an interaction that should be calculated differently from others.
           index -- the index of the interaction for which to get parameters
           particle1 -- the index of the first particle involved in the interaction
           particle2 -- the index of the second particle involved in the interaction
           chargeProd -- the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getExceptionParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.elementary_charge*unit.elementary_charge)
        val[3]=unit.Quantity(val[3], unit.nanometer)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole)


        return val

    def setExceptionParameters(self, *args):
        """
        setExceptionParameters(self, int index, int particle1, int particle2, double chargeProd, 
            double sigma, double epsilon)

        Set the force field parameters for an interaction that should be calculated differently from others. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations.
           index -- the index of the interaction for which to get parameters
           particle1 -- the index of the first particle involved in the interaction
           particle2 -- the index of the second particle involved in the interaction
           chargeProd -- the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setExceptionParameters(self, *args)

    def createExceptionsFromBonds(self, *args):
        """
        createExceptionsFromBonds(self, vectorpairii bonds, double coulomb14Scale, double lj14Scale)

        Identify exceptions based on the molecular topology. Particles which are separated by one or two bonds are set to not interact at all, while pairs of particles separated by three bonds (known as "1-4 interactions") have their Coulomb and Lennard-Jones interactions reduced by a fixed factor.
           bonds -- the set of bonds based on which to construct exceptions. Each element specifies the indices of two particles that are bonded to each other.
           coulomb14Scale -- pairs of particles separated by three bonds will have the strength of their Coulomb interaction multiplied by this factor
           lj14Scale -- pairs of particles separated by three bonds will have the strength of their Lennard-Jones interaction multiplied by this factor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_createExceptionsFromBonds(self, *args)

    def getUseDispersionCorrection(self):
        """
        getUseDispersionCorrection(self) -> bool

        Get whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getUseDispersionCorrection(self)

    def setUseDispersionCorrection(self, *args):
        """
        setUseDispersionCorrection(self, bool useCorrection)

        Set whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setUseDispersionCorrection(self, *args)

    def addParticle_usingRVdw(self, charge, rVDW, epsilon):
        """Add particle using elemetrary charge.  Rvdw and epsilon,
           which is consistent with AMBER parameter file usage.
           Note that the sum of the radii of the two interacting atoms is
           the minimum energy point in the Lennard Jones potential and
           is often called rMin.  The conversion from sigma follows:
           rVDW = 2^1/6 * sigma/2
        """
        return self.addParticle(charge, rVDW/RVDW_PER_SIGMA, epsilon)

    def addException_usingRMin(self, particle1, particle2,
                               chargeProd, rMin, epsilon):
        """Add interaction exception using the product of the two atoms'
           elementary charges, rMin and epsilon, which is standard for AMBER
           force fields.  Note that rMin is the minimum energy point in the
           Lennard Jones potential.  The conversion from sigma is:
           rMin = 2^1/6 * sigma.
        """
        return self.addException(particle1, particle2,
                                 chargeProd, rMin/RMIN_PER_SIGMA, epsilon)

    def __init__(self, *args): 
        """
        __init__(self) -> NonbondedForce
        __init__(self, NonbondedForce other) -> NonbondedForce

        Create a NonbondedForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_NonbondedForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_NonbondedForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

NonbondedForce_swigregister = _openmm.NonbondedForce_swigregister
NonbondedForce_swigregister(NonbondedForce)

class NonbondedSoftcoreForce(Force):
    """Proxy of C++ OpenMM::NonbondedSoftcoreForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NonbondedSoftcoreForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NonbondedSoftcoreForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.NonbondedSoftcoreForce_NoCutoff
    CutoffNonPeriodic = _openmm.NonbondedSoftcoreForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.NonbondedSoftcoreForce_CutoffPeriodic
    Ewald = _openmm.NonbondedSoftcoreForce_Ewald
    PME = _openmm.NonbondedSoftcoreForce_PME
    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles for which force field parameters have been defined.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_getNumParticles(self)

    def getNumExceptions(self):
        """
        getNumExceptions(self) -> int

        Get the number of special interactions that should be calculated differently from other interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_getNumExceptions(self)

    def getNonbondedMethod(self):
        """
        getNonbondedMethod(self) -> NonbondedSoftcoreMethod

        Get the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_getNonbondedMethod(self)

    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(self, NonbondedSoftcoreMethod method)

        Set the method used for handling long range nonbonded interactions.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_setNonbondedMethod(self, *args)

    def getCutoffDistance(self):
        """
        getCutoffDistance(self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedSoftcoreForce_getCutoffDistance(self)
        val=unit.Quantity(val, unit.nanometers)


        return val

    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_setCutoffDistance(self, *args)

    def getEwaldErrorTolerance(self):
        """
        getEwaldErrorTolerance(self) -> double

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_getEwaldErrorTolerance(self)

    def setEwaldErrorTolerance(self, *args):
        """
        setEwaldErrorTolerance(self, double tol)

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_setEwaldErrorTolerance(self, *args)

    def getReactionFieldDielectric(self):
        """
        getReactionFieldDielectric(self) -> double

        Get the dielectric constant to use for the solvent in the reaction field approximation.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedSoftcoreForce_getReactionFieldDielectric(self)
        val=unit.Quantity(val, unit.dimensionless)


        return val

    def setReactionFieldDielectric(self, *args):
        """
        setReactionFieldDielectric(self, double dielectric)

        Set the dielectric constant to use for the solvent in the reaction field approximation.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_setReactionFieldDielectric(self, *args)

    def addParticle(self, *args):
        """
        addParticle(self, double charge, double sigma, double epsilon, double softcoreLJLambda = 1.0) -> int
        addParticle(self, double charge, double sigma, double epsilon) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle. For calculating the Lennard-Jones interaction between two particles, the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles is used (the Lorentz-Bertelot combining rule).
           charge -- the charge of the particle, measured in units of the proton charge
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           softcoreLJLambda -- the soft-core LJ parameter (default: 1.0)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_addParticle(self, *args)

    def getParticleParameters(self, *args):
        """
        getParticleParameters(self, int index)

        Get the nonbonded force parameters for a particle.
           index -- the index of the particle for which to get parameters
           charge -- the charge of the particle, measured in units of the proton charge
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           softcoreLJLambda -- the soft-core LJ parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedSoftcoreForce_getParticleParameters(self, *args)
        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)
        val[3]=unit.Quantity(val[3], unit.dimensionless)


        return val

    def setParticleParameters(self, *args):
        """
        setParticleParameters(self, int index, double charge, double sigma, double epsilon, 
            double softcoreLJLambda = 1.0)
        setParticleParameters(self, int index, double charge, double sigma, double epsilon)

        Set the nonbonded force parameters for a particle. When calculating the Lennard-Jones interaction between two particles, it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles (the Lorentz-Bertelot combining rule).
           index -- the index of the particle for which to set parameters
           charge -- the charge of the particle, measured in units of the proton charge
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           softcoreLJLambda -- the soft-core LJ parameter (default: 1.0)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_setParticleParameters(self, *args)

    def addException(self, *args):
        """
        addException(self, int particle1, int particle2, double chargeProd, double sigma, 
            double epsilon, bool replace = False, 
            double softcoreLJLambda = 1.0) -> int
        addException(self, int particle1, int particle2, double chargeProd, double sigma, 
            double epsilon, bool replace = False) -> int
        addException(self, int particle1, int particle2, double chargeProd, double sigma, 
            double epsilon) -> int

        Add an interaction to the list of exceptions that should be calculated differently from other interactions. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations.In many cases, you can use createExceptionsFromBonds() rather than adding each exception explicitly.
           particle1 -- the index of the first particle involved in the interaction
           particle2 -- the index of the second particle involved in the interaction
           chargeProd -- the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           softcoreLJLambda -- the soft-core LJ parameter
           replace -- determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_addException(self, *args)

    def getExceptionParameters(self, *args):
        """
        getExceptionParameters(self, int index)

        Get the force field parameters for an interaction that should be calculated differently from others.
           index -- the index of the interaction for which to get parameters
           particle1 -- the index of the first particle involved in the interaction
           particle2 -- the index of the second particle involved in the interaction
           chargeProd -- the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           softcoreLJLambda -- the soft-core LJ parameter
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedSoftcoreForce_getExceptionParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.elementary_charge*unit.elementary_charge)
        val[3]=unit.Quantity(val[3], unit.nanometer)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole)
        val[5]=unit.Quantity(val[5], unit.dimensionless)


        return val

    def setExceptionParameters(self, *args):
        """
        setExceptionParameters(self, int index, int particle1, int particle2, double chargeProd, 
            double sigma, double epsilon, double softcoreLJLambda = 1.0)
        setExceptionParameters(self, int index, int particle1, int particle2, double chargeProd, 
            double sigma, double epsilon)

        Set the force field parameters for an interaction that should be calculated differently from others. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations.
           index -- the index of the interaction for which to get parameters
           particle1 -- the index of the first particle involved in the interaction
           particle2 -- the index of the second particle involved in the interaction
           chargeProd -- the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
           sigma -- the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
           epsilon -- the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
           softcoreLJLambda -- the soft-core LJ parameter (default: 1.0)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_setExceptionParameters(self, *args)

    def createExceptionsFromBonds(self, *args):
        """
        createExceptionsFromBonds(self, vectorpairii bonds, double coulomb14Scale, double lj14Scale)

        Identify exceptions based on the molecular topology. Particles which are separated by one or two bonds are set to not interact at all, while pairs of particles separated by three bonds (known as "1-4 interactions") have their Coulomb and Lennard-Jones interactions reduced by a fixed factor.
           bonds -- the set of bonds based on which to construct exceptions. Each element specifies the indices of two particles that are bonded to each other.
           coulomb14Scale -- pairs of particles separated by three bonds will have the strength of their Coulomb interaction multiplied by this factor
           lj14Scale -- pairs of particles separated by three bonds will have the strength of their Lennard-Jones interaction multiplied by this factor
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedSoftcoreForce_createExceptionsFromBonds(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> NonbondedSoftcoreForce
        __init__(self, NonbondedSoftcoreForce other) -> NonbondedSoftcoreForce

        Create a NonbondedSoftcoreForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_NonbondedSoftcoreForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_NonbondedSoftcoreForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

NonbondedSoftcoreForce_swigregister = _openmm.NonbondedSoftcoreForce_swigregister
NonbondedSoftcoreForce_swigregister(NonbondedSoftcoreForce)

class OpenMMException(_object):
    """Proxy of C++ OpenMM::OpenMMException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OpenMMException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OpenMMException, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_OpenMMException
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

    def what(self):
        """what(self) -> char"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.OpenMMException_what(self)

    def __init__(self, *args): 
        """
        __init__(self, string message) -> OpenMMException
        __init__(self, OpenMMException other) -> OpenMMException
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_OpenMMException(*args)
        try: self.this.append(this)
        except: self.this = this
OpenMMException_swigregister = _openmm.OpenMMException_swigregister
OpenMMException_swigregister(OpenMMException)

class PeriodicTorsionForce(Force):
    """Proxy of C++ OpenMM::PeriodicTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PeriodicTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PeriodicTorsionForce, name)
    __repr__ = _swig_repr
    def getNumTorsions(self):
        """
        getNumTorsions(self) -> int

        Get the number of periodic torsion terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_getNumTorsions(self)

    def addTorsion(self, *args):
        """
        addTorsion(self, int particle1, int particle2, int particle3, int particle4, 
            int periodicity, double phase, double k) -> int

        Add a periodic torsion term to the force field.
           particle1 -- the index of the first particle forming the torsion
           particle2 -- the index of the second particle forming the torsion
           particle3 -- the index of the third particle forming the torsion
           particle3 -- the index of the fourth particle forming the torsion
           periodicity -- the periodicity of the torsion
           phase -- the phase offset of the torsion, measured in radians
           k -- the force constant for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_addTorsion(self, *args)

    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(self, int index)

        Get the force field parameters for a periodic torsion term.
           index -- the index of the torsion for which to get parameters
           particle1 -- the index of the first particle forming the torsion
           particle2 -- the index of the second particle forming the torsion
           particle3 -- the index of the third particle forming the torsion
           particle3 -- the index of the fourth particle forming the torsion
           periodicity -- the periodicity of the torsion
           phase -- the phase offset of the torsion, measured in radians
           k -- the force constant for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.PeriodicTorsionForce_getTorsionParameters(self, *args)
        val[5]=unit.Quantity(val[5], unit.radian)
        val[6]=unit.Quantity(val[6], unit.kilojoule_per_mole)


        return val

    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, int periodicity, double phase, 
            double k)

        Set the force field parameters for a periodic torsion term.
           index -- the index of the torsion for which to set parameters
           particle1 -- the index of the first particle forming the torsion
           particle2 -- the index of the second particle forming the torsion
           particle3 -- the index of the third particle forming the torsion
           particle3 -- the index of the fourth particle forming the torsion
           periodicity -- the periodicity of the torsion
           phase -- the phase offset of the torsion, measured in radians
           k -- the force constant for the torsion
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_setTorsionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> PeriodicTorsionForce
        __init__(self, PeriodicTorsionForce other) -> PeriodicTorsionForce

        Create a PeriodicTorsionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_PeriodicTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_PeriodicTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

PeriodicTorsionForce_swigregister = _openmm.PeriodicTorsionForce_swigregister
PeriodicTorsionForce_swigregister(PeriodicTorsionForce)

class Platform(_object):
    """Proxy of C++ OpenMM::Platform class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Platform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Platform, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Platform
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

    def registerPlatform(*args):
        """
        registerPlatform(Platform platform)

        Register a new Platform.
        """
        if not args[0].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[0].__class__.__name__
           raise Exception(s)


        val = _openmm.Platform_registerPlatform(*args)
        args[0].thisown=0


        return val

    if _newclass:registerPlatform = staticmethod(registerPlatform)
    __swig_getmethods__["registerPlatform"] = lambda x: registerPlatform
    def getNumPlatforms():
        """
        getNumPlatforms() -> int

        Get the number of Platforms that have been registered.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getNumPlatforms()

    if _newclass:getNumPlatforms = staticmethod(getNumPlatforms)
    __swig_getmethods__["getNumPlatforms"] = lambda x: getNumPlatforms
    def getPlatform(*args):
        """
        getPlatform(int index) -> Platform

        Get a registered Platform by index.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPlatform(*args)

    if _newclass:getPlatform = staticmethod(getPlatform)
    __swig_getmethods__["getPlatform"] = lambda x: getPlatform
    def getPlatformByName(*args):
        """
        getPlatformByName(string name) -> Platform

        Get the registered Platform with a particular name. If no Platform with that name has been registered, this throws an exception.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPlatformByName(*args)

    if _newclass:getPlatformByName = staticmethod(getPlatformByName)
    __swig_getmethods__["getPlatformByName"] = lambda x: getPlatformByName
    def findPlatform(*args):
        """
        findPlatform(vectorstring kernelNames) -> Platform

        Find a Platform which can be used to perform a calculation.
           kernelNames -- the names of all kernels which will be needed for the calculation
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_findPlatform(*args)

    if _newclass:findPlatform = staticmethod(findPlatform)
    __swig_getmethods__["findPlatform"] = lambda x: findPlatform
    def loadPluginLibrary(*args):
        """
        loadPluginLibrary(string file)

        Load a dynamic library (DLL) which contains an OpenMM plugin. Typically, each Platform is distributed as a separate dynamic library. This method can then be called at runtime to load each available library. Each library should contain an initializer function to register any Platforms and KernelFactories that it contains.If the file does not exist or cannot be loaded, an exception is thrown.
           file -- the path to the dynamic library file. This is interpreted using the operating system's rules for loading libraries. Typically it may be either an absolute path or relative to a set of standard locations.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_loadPluginLibrary(*args)

    if _newclass:loadPluginLibrary = staticmethod(loadPluginLibrary)
    __swig_getmethods__["loadPluginLibrary"] = lambda x: loadPluginLibrary
    def loadPluginsFromDirectory(*args):
        """
        loadPluginsFromDirectory(string directory) -> vectorstring

        Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from a single directory. This method loops over every file contained in the specified directory and calls loadPluginLibrary() for each one. If an error occurs while trying to load a particular file, that file is simply ignored.
           directory -- the path to the directory containing libraries to load
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_loadPluginsFromDirectory(*args)

    if _newclass:loadPluginsFromDirectory = staticmethod(loadPluginsFromDirectory)
    __swig_getmethods__["loadPluginsFromDirectory"] = lambda x: loadPluginsFromDirectory
    def getDefaultPluginsDirectory():
        """
        getDefaultPluginsDirectory() -> string

        Get the default directory from which to load plugins. If the environment variable OPENMM_PLUGIN_DIR is set, this returns its value. Otherwise, it returns a platform specific default location.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getDefaultPluginsDirectory()

    if _newclass:getDefaultPluginsDirectory = staticmethod(getDefaultPluginsDirectory)
    __swig_getmethods__["getDefaultPluginsDirectory"] = lambda x: getDefaultPluginsDirectory
    def getOpenMMVersion():
        """
        getOpenMMVersion() -> string

        Get a string containing the version number of the OpenMM library.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getOpenMMVersion()

    if _newclass:getOpenMMVersion = staticmethod(getOpenMMVersion)
    __swig_getmethods__["getOpenMMVersion"] = lambda x: getOpenMMVersion
    def getName(self):
        """
        getName(self) -> string

        Get the name of this platform. This should be a unique identifier which can be used to recognized it.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getName(self)

    def getSpeed(self):
        """
        getSpeed(self) -> double

        Get an estimate of how fast this Platform class is. This need not be precise. It only is expected to return an order or magnitude estimate of the relative performance of different Platform classes. An unoptimized reference implementation should return 1.0, and all other Platforms should return a larger value that is an estimate of how many times faster they are than the reference implementation.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getSpeed(self)

    def supportsDoublePrecision(self):
        """
        supportsDoublePrecision(self) -> bool

        Get whether this Platform supports double precision arithmetic. If this returns false, the platform is permitted to represent double precision values internally as single precision.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_supportsDoublePrecision(self)

    def getPropertyNames(self):
        """
        getPropertyNames(self) -> vectorstring

        Get the names of all Platform-specific properties this Platform supports.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPropertyNames(self)

    def getPropertyValue(self, *args):
        """
        getPropertyValue(self, Context context, string property) -> string

        Get the value of a Platform-specific property for a Context.
           context -- the Context for which to get the property
           property -- the name of the property to get
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPropertyValue(self, *args)

    def setPropertyValue(self, *args):
        """
        setPropertyValue(self, Context context, string property, string value)

        Set the value of a Platform-specific property for a Context.
           context -- the Context for which to set the property
           property -- the name of the property to set
           value -- the value to set for the property
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_setPropertyValue(self, *args)

    def getPropertyDefaultValue(self, *args):
        """
        getPropertyDefaultValue(self, string property) -> string

        Get the default value of a Platform-specific property. This is the value that will be used for newly created Contexts.
           property -- the name of the property to get
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPropertyDefaultValue(self, *args)

    def setPropertyDefaultValue(self, *args):
        """
        setPropertyDefaultValue(self, string property, string value)

        Set the default value of a Platform-specific property. This is the value that will be used for newly created Contexts.
           property -- the name of the property to set
           value -- the value to set for the property
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_setPropertyDefaultValue(self, *args)

    def supportsKernels(self, *args):
        """
        supportsKernels(self, vectorstring kernelNames) -> bool

        Determine whether this Platforms provides implementations of a set of kernels.
           kernelNames -- the names of the kernels of interests
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_supportsKernels(self, *args)

Platform_swigregister = _openmm.Platform_swigregister
Platform_swigregister(Platform)

def Platform_registerPlatform(*args):
  """
    Platform_registerPlatform(Platform platform)

    Register a new Platform.
    """
  if not args[0].thisown:
     s = "the %s object does not own its corresponding OpenMM object" \
        % args[0].__class__.__name__
     raise Exception(s)


  val = _openmm.Platform_registerPlatform(*args)
  args[0].thisown=0


  return val

def Platform_getNumPlatforms():
  """
    Platform_getNumPlatforms() -> int

    Get the number of Platforms that have been registered.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_getNumPlatforms()

def Platform_getPlatform(*args):
  """
    Platform_getPlatform(int index) -> Platform

    Get a registered Platform by index.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_getPlatform(*args)

def Platform_getPlatformByName(*args):
  """
    Platform_getPlatformByName(string name) -> Platform

    Get the registered Platform with a particular name. If no Platform with that name has been registered, this throws an exception.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_getPlatformByName(*args)

def Platform_findPlatform(*args):
  """
    Platform_findPlatform(vectorstring kernelNames) -> Platform

    Find a Platform which can be used to perform a calculation.
       kernelNames -- the names of all kernels which will be needed for the calculation
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_findPlatform(*args)

def Platform_loadPluginLibrary(*args):
  """
    Platform_loadPluginLibrary(string file)

    Load a dynamic library (DLL) which contains an OpenMM plugin. Typically, each Platform is distributed as a separate dynamic library. This method can then be called at runtime to load each available library. Each library should contain an initializer function to register any Platforms and KernelFactories that it contains.If the file does not exist or cannot be loaded, an exception is thrown.
       file -- the path to the dynamic library file. This is interpreted using the operating system's rules for loading libraries. Typically it may be either an absolute path or relative to a set of standard locations.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_loadPluginLibrary(*args)

def Platform_loadPluginsFromDirectory(*args):
  """
    Platform_loadPluginsFromDirectory(string directory) -> vectorstring

    Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from a single directory. This method loops over every file contained in the specified directory and calls loadPluginLibrary() for each one. If an error occurs while trying to load a particular file, that file is simply ignored.
       directory -- the path to the directory containing libraries to load
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_loadPluginsFromDirectory(*args)

def Platform_getDefaultPluginsDirectory():
  """
    Platform_getDefaultPluginsDirectory() -> string

    Get the default directory from which to load plugins. If the environment variable OPENMM_PLUGIN_DIR is set, this returns its value. Otherwise, it returns a platform specific default location.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_getDefaultPluginsDirectory()

def Platform_getOpenMMVersion():
  """
    Platform_getOpenMMVersion() -> string

    Get a string containing the version number of the OpenMM library.
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.Platform_getOpenMMVersion()

class RBTorsionForce(Force):
    """Proxy of C++ OpenMM::RBTorsionForce class"""
    __swig_setmethods__ = {}
    for _s in [Force]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RBTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RBTorsionForce, name)
    __repr__ = _swig_repr
    def getNumTorsions(self):
        """
        getNumTorsions(self) -> int

        Get the number of Ryckaert-Bellemans torsion terms in the potential function
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_getNumTorsions(self)

    def addTorsion(self, *args):
        """
        addTorsion(self, int particle1, int particle2, int particle3, int particle4, 
            double c0, double c1, double c2, double c3, 
            double c4, double c5) -> int

        Add a Ryckaert-Bellemans torsion term to the force field.
           particle1 -- the index of the first particle forming the torsion
           particle2 -- the index of the second particle forming the torsion
           particle3 -- the index of the third particle forming the torsion
           particle3 -- the index of the fourth particle forming the torsion
           c0 -- the coefficient of the constant term, measured in kJ/mol
           c1 -- the coefficient of the 1st order term, measured in kJ/mol
           c2 -- the coefficient of the 2nd order term, measured in kJ/mol
           c3 -- the coefficient of the 3rd order term, measured in kJ/mol
           c4 -- the coefficient of the 4th order term, measured in kJ/mol
           c5 -- the coefficient of the 5th order term, measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_addTorsion(self, *args)

    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(self, int index)

        Get the force field parameters for a Ryckaert-Bellemans torsion term.
           index -- the index of the torsion for which to get parameters
           particle1 -- the index of the first particle forming the torsion
           particle2 -- the index of the second particle forming the torsion
           particle3 -- the index of the third particle forming the torsion
           particle3 -- the index of the fourth particle forming the torsion
           c0 -- the coefficient of the constant term, measured in kJ/mol
           c1 -- the coefficient of the 1st order term, measured in kJ/mol
           c2 -- the coefficient of the 2nd order term, measured in kJ/mol
           c3 -- the coefficient of the 3rd order term, measured in kJ/mol
           c4 -- the coefficient of the 4th order term, measured in kJ/mol
           c5 -- the coefficient of the 5th order term, measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_getTorsionParameters(self, *args)

    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(self, int index, int particle1, int particle2, int particle3, 
            int particle4, double c0, double c1, double c2, 
            double c3, double c4, double c5)

        Set the force field parameters for a Ryckaert-Bellemans torsion term.
           index -- the index of the torsion for which to set parameters
           particle1 -- the index of the first particle forming the torsion
           particle2 -- the index of the second particle forming the torsion
           particle3 -- the index of the third particle forming the torsion
           particle3 -- the index of the fourth particle forming the torsion
           c0 -- the coefficient of the constant term, measured in kJ/mol
           c1 -- the coefficient of the 1st order term, measured in kJ/mol
           c2 -- the coefficient of the 2nd order term, measured in kJ/mol
           c3 -- the coefficient of the 3rd order term, measured in kJ/mol
           c4 -- the coefficient of the 4th order term, measured in kJ/mol
           c5 -- the coefficient of the 5th order term, measured in kJ/mol
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_setTorsionParameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> RBTorsionForce
        __init__(self, RBTorsionForce other) -> RBTorsionForce

        Create a RBTorsionForce.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_RBTorsionForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_RBTorsionForce
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

RBTorsionForce_swigregister = _openmm.RBTorsionForce_swigregister
RBTorsionForce_swigregister(RBTorsionForce)

class SerializationNode(_object):
    """Proxy of C++ OpenMM::SerializationNode class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SerializationNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SerializationNode, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def getName(self):
        """
        getName(self) -> string

        Get the name of this SerializationNode.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getName(self)

    def setName(self, *args):
        """
        setName(self, string name)

        Set the name of this SerializationNode.
           name -- the new name of the SerializationNode
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setName(self, *args)

    def getChildren(self, *args):
        """
        getChildren(self) -> std::vector<(OpenMM::SerializationNode,std::allocator<(OpenMM::SerializationNode)>)>
        getChildren(self) -> std::vector<(OpenMM::SerializationNode,std::allocator<(OpenMM::SerializationNode)>)>

        Get a reference to this node's child nodes.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getChildren(self, *args)

    def getChildNode(self, *args):
        """
        getChildNode(self, string name) -> SerializationNode
        getChildNode(self, string name) -> SerializationNode

        Get a reference to the child node with a particular name. If there is no child with the specified name, this throws an exception.
           the -- name of the child node to get
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getChildNode(self, *args)

    def getProperties(self):
        """
        getProperties(self) -> std::map<(std::string,std::string)>

        Get a map containing all of this node's properties.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getProperties(self)

    def hasProperty(self, *args):
        """
        hasProperty(self, string name) -> bool

        Determine whether this node has a property with a particular node.
           the -- name of the property to check for
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_hasProperty(self, *args)

    def getStringProperty(self, *args):
        """
        getStringProperty(self, string name) -> string
        getStringProperty(self, string name, string defaultValue) -> string

        Get the property with a particular name, specified as a string. If there is no property with the specified name, a default value is returned instead.
           name -- the name of the property to get
           defaultValue -- the value to return if the specified property does not exist
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getStringProperty(self, *args)

    def setStringProperty(self, *args):
        """
        setStringProperty(self, string name, string value) -> SerializationNode

        Set the value of a property, specified as a string.
           name -- the name of the property to set
           value -- the value to set for the property
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setStringProperty(self, *args)

    def getIntProperty(self, *args):
        """
        getIntProperty(self, string name) -> int
        getIntProperty(self, string name, int defaultValue) -> int

        Get the property with a particular name, specified as an int. If there is no property with the specified name, a default value is returned instead.
           name -- the name of the property to get
           defaultValue -- the value to return if the specified property does not exist
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getIntProperty(self, *args)

    def setIntProperty(self, *args):
        """
        setIntProperty(self, string name, int value) -> SerializationNode

        Set the value of a property, specified as an int.
           name -- the name of the property to set
           value -- the value to set for the property
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setIntProperty(self, *args)

    def getDoubleProperty(self, *args):
        """
        getDoubleProperty(self, string name) -> double
        getDoubleProperty(self, string name, double defaultValue) -> double

        Get the property with a particular name, specified as a double. If there is no property with the specified name, a default value is returned instead.
           name -- the name of the property to get
           defaultValue -- the value to return if the specified property does not exist
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getDoubleProperty(self, *args)

    def setDoubleProperty(self, *args):
        """
        setDoubleProperty(self, string name, double value) -> SerializationNode

        Set the value of a property, specified as a double.
           name -- the name of the property to set
           value -- the value to set for the property
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setDoubleProperty(self, *args)

    def createChildNode(self, *args):
        """
        createChildNode(self, string name) -> SerializationNode

        Create a new child node by serializing an object. A SerializationProxy is automatically selected based on the object's type, then invoked to populate the newly created node.Note that, while this method is templatized based on the type of object being serialized, the typeid() operator is used to select the proxy. This means the template argument may be a base class, and the correct proxies will still be selected for objects of different subclasses.
           name -- the name of the new node to create
           object -- a pointer to the object to serialize
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_createChildNode(self, *args)

    __swig_destroy__ = _openmm.delete_SerializationNode
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

SerializationNode_swigregister = _openmm.SerializationNode_swigregister
SerializationNode_swigregister(SerializationNode)

class SerializationProxy(_object):
    """Proxy of C++ OpenMM::SerializationProxy class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SerializationProxy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SerializationProxy, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def registerProxy(*args):
        """
        registerProxy(std::type_info type, SerializationProxy proxy)

        Register a SerializationProxy to be used for objects of a particular type.
           type -- the type_info for the object type
           proxy -- the proxy to use for objects of the specified type
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_registerProxy(*args)

    if _newclass:registerProxy = staticmethod(registerProxy)
    __swig_getmethods__["registerProxy"] = lambda x: registerProxy
    def getProxy(*args):
        """
        getProxy(string typeName) -> SerializationProxy
        getProxy(std::type_info type) -> SerializationProxy

        Get the SerializationProxy to use for objects of a particular type, specified by type_info.
           type -- the type_info of the object type to get a proxy for
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_getProxy(*args)

    if _newclass:getProxy = staticmethod(getProxy)
    __swig_getmethods__["getProxy"] = lambda x: getProxy
    def getTypeName(self):
        """
        getTypeName(self) -> string

        Get the name of the object type this proxy manipulates, as passed to the constructor.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_getTypeName(self)

    def serialize(self, *args):
        """
        serialize(self, void object, SerializationNode node)

        Subclasses implement this method to record information about an object being serialized.
           object -- a pointer to the object being serialized
           node -- all data to be serialized should be stored into this node, either directly as properties or indirectly by adding child nodes to it
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_serialize(self, *args)

    def deserialize(self, *args):
        """
        deserialize(self, SerializationNode node) -> void

        Reconstruct an object from its serialized data.
           node -- a SerializationNode containing the object's description
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_deserialize(self, *args)

    __swig_destroy__ = _openmm.delete_SerializationProxy
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

SerializationProxy_swigregister = _openmm.SerializationProxy_swigregister
SerializationProxy_swigregister(SerializationProxy)

def SerializationProxy_registerProxy(*args):
  """
    SerializationProxy_registerProxy(std::type_info type, SerializationProxy proxy)

    Register a SerializationProxy to be used for objects of a particular type.
       type -- the type_info for the object type
       proxy -- the proxy to use for objects of the specified type
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.SerializationProxy_registerProxy(*args)

def SerializationProxy_getProxy(*args):
  """
    getProxy(string typeName) -> SerializationProxy
    SerializationProxy_getProxy(std::type_info type) -> SerializationProxy

    Get the SerializationProxy to use for objects of a particular type, specified by type_info.
       type -- the type_info of the object type to get a proxy for
    """
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.SerializationProxy_getProxy(*args)

class System(_object):
    """Proxy of C++ OpenMM::System class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, System, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, System, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_System
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

    def getNumParticles(self):
        """
        getNumParticles(self) -> int

        Get the number of particles in this System.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getNumParticles(self)

    def addParticle(self, *args):
        """
        addParticle(self, double mass) -> int

        Add a particle to the System.
           mass -- the mass of the particle (in atomic mass units)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_addParticle(self, *args)

    def getParticleMass(self, *args):
        """
        getParticleMass(self, int index) -> double

        Get the mass (in atomic mass units) of a particle.
           index -- the index of the particle for which to get the mass
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.System_getParticleMass(self, *args)
        val=unit.Quantity(val, unit.amu)


        return val

    def setParticleMass(self, *args):
        """
        setParticleMass(self, int index, double mass)

        Set the mass (in atomic mass units) of a particle.
           index -- the index of the particle for which to set the mass
           mass -- the mass of the particle
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_setParticleMass(self, *args)

    def getNumConstraints(self):
        """
        getNumConstraints(self) -> int

        Get the number of distance constraints in this System.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getNumConstraints(self)

    def addConstraint(self, *args):
        """
        addConstraint(self, int particle1, int particle2, double distance) -> int

        Add a constraint to the System.
           particle1 -- the index of the first particle involved in the constraint
           particle2 -- the index of the second particle involved in the constraint
           distance -- the required distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_addConstraint(self, *args)

    def getConstraintParameters(self, *args):
        """
        getConstraintParameters(self, int index)

        Get the parameters defining a distance constraint.
           index -- the index of the constraint for which to get parameters
           particle1 -- the index of the first particle involved in the constraint
           particle2 -- the index of the second particle involved in the constraint
           distance -- the required distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.System_getConstraintParameters(self, *args)
        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val

    def setConstraintParameters(self, *args):
        """
        setConstraintParameters(self, int index, int particle1, int particle2, double distance)

        Set the parameters defining a distance constraint.
           index -- the index of the constraint for which to set parameters
           particle1 -- the index of the first particle involved in the constraint
           particle2 -- the index of the second particle involved in the constraint
           distance -- the required distance between the two particles, measured in nm
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_setConstraintParameters(self, *args)

    def addForce(self, *args):
        """
        addForce(self, Force force) -> int

        Add a Force to the System. The Force should have been created on the heap with the "new" operator. The System takes over ownership of it, and deletes the Force when the System itself is deleted.
           force -- a pointer to the Force object to be added
        """
        if not args[0].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[0].__class__.__name__
           raise Exception(s)


        val = _openmm.System_addForce(self, *args)
        args[0].thisown=0


        return val

    def getNumForces(self):
        """
        getNumForces(self) -> int

        Get the number of Force objects that have been added to the System.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getNumForces(self)

    def getForce(self, *args):
        """
        getForce(self, int index) -> Force
        getForce(self, int index) -> Force

        Get a writable reference to one of the Forces in this System.
           index -- the index of the Force to get
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getForce(self, *args)

    def getDefaultPeriodicBoxVectors(self):
        """
        getDefaultPeriodicBoxVectors(self)

        Get the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions.Currently, only rectangular boxes are supported. This means that a, b, and c must be aligned with the x, y, and z axes respectively. Future releases may support arbitrary triclinic boxes.
           a -- on exit, this contains the vector defining the first edge of the periodic box
           b -- on exit, this contains the vector defining the second edge of the periodic box
           c -- on exit, this contains the vector defining the third edge of the periodic box
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.System_getDefaultPeriodicBoxVectors(self)
        val[0]=unit.Quantity(val[0], unit.nanometer)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val

    def setDefaultPeriodicBoxVectors(self, *args):
        """
        setDefaultPeriodicBoxVectors(self, Vec3 a, Vec3 b, Vec3 c)

        Set the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions.Currently, only rectangular boxes are supported. This means that a, b, and c must be aligned with the x, y, and z axes respectively. Future releases may support arbitrary triclinic boxes.
           a -- the vector defining the first edge of the periodic box
           b -- the vector defining the second edge of the periodic box
           c -- the vector defining the third edge of the periodic box
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_setDefaultPeriodicBoxVectors(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> System
        __init__(self, System other) -> System

        Create a new System.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_System(*args)
        try: self.this.append(this)
        except: self.this = this
System_swigregister = _openmm.System_swigregister
System_swigregister(System)

class VariableLangevinIntegrator(Integrator):
    """Proxy of C++ OpenMM::VariableLangevinIntegrator class"""
    __swig_setmethods__ = {}
    for _s in [Integrator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableLangevinIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableLangevinIntegrator, name)
    __repr__ = _swig_repr
    def getTemperature(self):
        """
        getTemperature(self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.VariableLangevinIntegrator_getTemperature(self)
        val=unit.Quantity(val, unit.kelvin)


        return val

    def setTemperature(self, *args):
        """
        setTemperature(self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           temp -- the temperature of the heat bath, measured in Kelvin
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setTemperature(self, *args)

    def getFriction(self):
        """
        getFriction(self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.VariableLangevinIntegrator_getFriction(self)
        val=unit.Quantity(val, 1/unit.picosecond)


        return val

    def setFriction(self, *args):
        """
        setFriction(self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           coeff -- the friction coefficient, measured in 1/ps
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setFriction(self, *args)

    def getErrorTolerance(self):
        """
        getErrorTolerance(self) -> double

        Get the error tolerance.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_getErrorTolerance(self)

    def setErrorTolerance(self, *args):
        """
        setErrorTolerance(self, double tol)

        Set the error tolerance.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setErrorTolerance(self, *args)

    def getRandomNumberSeed(self):
        """
        getRandomNumberSeed(self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_getRandomNumberSeed(self)

    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setRandomNumberSeed(self, *args)

    def step(self, *args):
        """
        step(self, int steps)

        Advance a simulation through time by taking a series of time steps.
           steps -- the number of time steps to take
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_step(self, *args)

    def stepTo(self, *args):
        """
        stepTo(self, double time)

        Advance a simulation through time by taking a series of steps until a specified time is reached. When this method returns, the simulation time will exactly equal the time which was specified. If you call this method and specify a time that is earlier than the current time, it will return without doing anything.
           time -- the time to which the simulation should be advanced
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_stepTo(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double temperature, double frictionCoeff, double errorTol) -> VariableLangevinIntegrator
        __init__(self, VariableLangevinIntegrator other) -> VariableLangevinIntegrator

        Create a VariableLangevinIntegrator.
           temperature -- the temperature of the heat bath (in Kelvin)
           frictionCoeff -- the friction coefficient which couples the system to the heat bath (in inverse picoseconds)
           errorTol -- the error tolerance
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_VariableLangevinIntegrator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_VariableLangevinIntegrator
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

VariableLangevinIntegrator_swigregister = _openmm.VariableLangevinIntegrator_swigregister
VariableLangevinIntegrator_swigregister(VariableLangevinIntegrator)

class VariableVerletIntegrator(Integrator):
    """Proxy of C++ OpenMM::VariableVerletIntegrator class"""
    __swig_setmethods__ = {}
    for _s in [Integrator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableVerletIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableVerletIntegrator, name)
    __repr__ = _swig_repr
    def getErrorTolerance(self):
        """
        getErrorTolerance(self) -> double

        Get the error tolerance.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_getErrorTolerance(self)

    def setErrorTolerance(self, *args):
        """
        setErrorTolerance(self, double tol)

        Set the error tolerance.
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_setErrorTolerance(self, *args)

    def step(self, *args):
        """
        step(self, int steps)

        Advance a simulation through time by taking a series of time steps.
           steps -- the number of time steps to take
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_step(self, *args)

    def stepTo(self, *args):
        """
        stepTo(self, double time)

        Advance a simulation through time by taking a series of steps until a specified time is reached. When this method returns, the simulation time will exactly equal the time which was specified. If you call this method and specify a time that is earlier than the current time, it will return without doing anything.
           time -- the time to which the simulation should be advanced
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_stepTo(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double errorTol) -> VariableVerletIntegrator
        __init__(self, VariableVerletIntegrator other) -> VariableVerletIntegrator

        Create a VariableVerletIntegrator.
           errorTol -- the error tolerance
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_VariableVerletIntegrator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_VariableVerletIntegrator
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

VariableVerletIntegrator_swigregister = _openmm.VariableVerletIntegrator_swigregister
VariableVerletIntegrator_swigregister(VariableVerletIntegrator)

class VerletIntegrator(Integrator):
    """Proxy of C++ OpenMM::VerletIntegrator class"""
    __swig_setmethods__ = {}
    for _s in [Integrator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VerletIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VerletIntegrator, name)
    __repr__ = _swig_repr
    def step(self, *args):
        """
        step(self, int steps)

        Advance a simulation through time by taking a series of time steps.
           steps -- the number of time steps to take
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VerletIntegrator_step(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, double stepSize) -> VerletIntegrator
        __init__(self, VerletIntegrator other) -> VerletIntegrator

        Create a VerletIntegrator.
           stepSize -- the step size with which to integrator the system (in picoseconds)
        """
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_VerletIntegrator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openmm.delete_VerletIntegrator
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

VerletIntegrator_swigregister = _openmm.VerletIntegrator_swigregister
VerletIntegrator_swigregister(VerletIntegrator)

class XmlSerializer(_object):
    """Proxy of C++ OpenMM::XmlSerializer class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XmlSerializer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XmlSerializer, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def serializeSystem(*args):
        """serializeSystem(System object) -> string"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.XmlSerializer_serializeSystem(*args)

    if _newclass:serializeSystem = staticmethod(serializeSystem)
    __swig_getmethods__["serializeSystem"] = lambda x: serializeSystem
    def deserializeSystem(*args):
        """deserializeSystem(char inputString) -> System"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.XmlSerializer_deserializeSystem(*args)

    if _newclass:deserializeSystem = staticmethod(deserializeSystem)
    __swig_getmethods__["deserializeSystem"] = lambda x: deserializeSystem
    __swig_destroy__ = _openmm.delete_XmlSerializer
    def __del__(self):
        """__del__(self)"""
        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

XmlSerializer_swigregister = _openmm.XmlSerializer_swigregister
XmlSerializer_swigregister(XmlSerializer)

def XmlSerializer_serializeSystem(*args):
  """XmlSerializer_serializeSystem(System object) -> string"""
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.XmlSerializer_serializeSystem(*args)

def XmlSerializer_deserializeSystem(*args):
  """XmlSerializer_deserializeSystem(char inputString) -> System"""
  try: args=stripUnits(args)
  except UnboundLocalError: pass


  return _openmm.XmlSerializer_deserializeSystem(*args)



